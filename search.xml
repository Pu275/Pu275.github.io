<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>买卖股票的最佳时机</title>
    <url>/posts/3068883604/</url>
    <content><![CDATA[<h2 id="买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#买卖股票的最佳时机"></a> 买卖股票的最佳时机</h2>
<p>《买卖股票的最佳时机》全集，动态规划。</p>
<span id="more"></span>
<hr>
<h2 id="121-买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#121-买卖股票的最佳时机"></a> 121. 买卖股票的最佳时机</h2>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p>
<h3 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h3>
<p><strong>定义状态：</strong> 定义一个二维数组 dp，行数是所有时刻即 prices 的长度，列数是 2，<strong>0 和 1</strong> 两个位置表示两种状态：</p>
<p><strong>当 i 时刻处于 0 位置：</strong> 代表此时选择持有股票能带来的最大收益（或者说最低的开销）；</p>
<p><strong>当 i 时刻处于 1 位置：</strong> 代表此时选择不持有股票能带来的最大收益。</p>
<p><strong>注意：</strong>  <strong>选择持有</strong> 并不代表一定要在那个时刻真的持有，有下面几种情况：</p>
<p>（1）上个时刻售出了，于是这个时刻只能买进新的（不管亏不亏），本题条件这种情况只可能发生在 i = 0 的时候；</p>
<p>（2）上个时刻持有，但是这个时刻的价格更低更理想，于是更新当前时刻的最优开销为在此时买入；</p>
<p>（3）上个时刻持有，但是这个时刻的价格高，不理想，便是维持继续持有，那么当前时刻的最优开销和上个时刻一致。</p>
<p>同样的分析可以类推到 <strong>选择不持有</strong> 上面：</p>
<p>（1）上个时刻持有，但是这个时刻的价格不错，于是更新当前时刻的最优开销为在此时卖出；</p>
<p>（2）上个时刻未持有，但是这个时刻的价格太高，不考虑买入持有。</p>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], -prices[i]);  <span class="comment">// 持有的成本尽可能低</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], prices[i] + dp[i<span class="number">-1</span>][<span class="number">0</span>]);  <span class="comment">// 卖出的收益尽可能高</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="122-买卖股票的最佳时机-ii"><a class="markdownIt-Anchor" href="#122-买卖股票的最佳时机-ii"></a> 122. 买卖股票的最佳时机 II</h2>
<h3 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h3>
<p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。</p>
<p>在每一天，你可能会决定购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以购买它，然后在 同一天 出售。<br>
返回 你能获得的 最大 利润 。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p>
<h3 id="解答-2"><a class="markdownIt-Anchor" href="#解答-2"></a> 解答</h3>
<p>上一题的情况是，第一列（持有列）除非遇到更实惠的价格，否则不会更新（因为只能买卖一次，所以挑最便宜的）</p>
<p>本题除了遇到低成本的价格，还要考虑上个时刻是否卖出（卖出的话新的时刻的收益就要得到更新，因为赚钱了）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上一题只需要更改次数即可</span></span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] - prices[i]);</span><br></pre></td></tr></table></figure>
<h3 id="相关题目"><a class="markdownIt-Anchor" href="#相关题目"></a> 相关题目</h3>
<p>714.买卖股票的最佳时机含手续费（差别就是卖出的时候 <strong>收益-手续费</strong> ）</p>
<p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p>
<h2 id="123-买卖股票的最佳时机-iii"><a class="markdownIt-Anchor" href="#123-买卖股票的最佳时机-iii"></a> 123. 买卖股票的最佳时机 III</h2>
<h3 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h3>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h3 id="解答-3"><a class="markdownIt-Anchor" href="#解答-3"></a> 解答</h3>
<p>和 <strong>122. 买卖股票的最佳时机 II</strong> 不同，这里是限制最多两次交易。</p>
<p>回忆 <strong>121. 买卖股票的最佳时机</strong> ，只有一次交易机会的写法是这样的（它与无限次交易的差别就在第一列）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], -prices[i]);  <span class="comment">// 买入只有一次机会，所以只挑最便宜的</span></span><br></pre></td></tr></table></figure>
<p>第一次持有、第一次卖出、第二次持有、第二次卖出，四个情况都依赖前面的情况。解决办法是增加两列。</p>
<p>第一次的买卖和 <strong>121. 买卖股票的最佳时机</strong> 是完全一样的思路。第二次买入根据第一次卖的结果更新，如果第一次卖出了好价，那么相应的第二次买入的收益也会随着提升；同样的思路用第二次买入的价格更新第二次卖出，最后推导出结果。</p>
<p>可以知道，第三列（第二次持有）一定是不差于第一列（因为第一次卖出不会亏钱），相应的第四列也不会差于第二列。所以不用担心没有机会第二次交易（比如 <code>[1,2,3,4,5,6]</code> 这种情况）</p>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];  <span class="comment">// 第一天买入</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">2</span>] = -prices[<span class="number">0</span>];  <span class="comment">// 第一天买入并卖出再买入</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], prices[i] + dp[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">        dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">3</span>], prices[i] + dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="188-买卖股票的最佳时机-iv"><a class="markdownIt-Anchor" href="#188-买卖股票的最佳时机-iv"></a> 188. 买卖股票的最佳时机 IV</h2>
<h3 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h3>
<p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/</a></p>
<h3 id="解答-4"><a class="markdownIt-Anchor" href="#解答-4"></a> 解答</h3>
<p>和上一题的区别就是，不止两次交易机会，所以要根据 k 的大小调整数组宽度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span> * k, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * k; i += <span class="number">2</span>) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">2</span> * k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], prices[i] + dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">2</span>*k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="309-最佳买卖股票时机含冷冻期"><a class="markdownIt-Anchor" href="#309-最佳买卖股票时机含冷冻期"></a> 309. 最佳买卖股票时机含冷冻期</h2>
<h3 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h3>
<p>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p>
<h3 id="解答-5"><a class="markdownIt-Anchor" href="#解答-5"></a> 解答</h3>
<p>类似 <strong>122. 买卖股票的最佳时机 II</strong>，区别在于，卖了以后的一天不能立刻买入，而且不一定要只冷却一天，可以顺便等待好多天等价格到低点再买入，所以需要将原来的 <strong>不持有状态</strong>（这个状态涵盖了（1）当前时刻正好卖出（2）之前已经卖出了，今天也不买入），拆解成两个状态：</p>
<ol>
<li>当前时刻卖出，导致进入无持有状态；</li>
<li>当前时刻并非卖出导致的无持有状态（之前时刻已经卖出了），有可能当前时刻正好是冷却期间，也有可能当前时刻只是价格不好。</li>
</ol>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<p>代码里面，状态零表示 <strong>持有</strong>，状态一表示 <strong>卖出导致的无持有</strong>， 状态二表示 <strong>非卖出导致的无持有</strong> ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>] - prices[i]);  <span class="comment">// 前一天就卖出不可能导致今天的更新哦</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], prices[i] + dp[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>]);  <span class="comment">// 可能是昨天卖出今天冷却；也可能是好几天前就卖掉了，一直没有买进来</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">1</span>], dp[n<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>139. 单词拆分</title>
    <url>/posts/1712133297/</url>
    <content><![CDATA[<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p>
<p><strong>注意：</strong> 不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<span id="more"></span>
<p><img src="/posts/1712133297/image-20220223154658379.png" alt="image-20220223154658379"></p>
]]></content>
  </entry>
  <entry>
    <title>300. 最长递增子序列</title>
    <url>/posts/3337128124/</url>
    <content><![CDATA[<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p><img src="/posts/3337128124/image-20220303014532879.png" alt="image-20220303014532879"></p>
<h3 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h3>
<p><strong>注意：</strong> 题目要求的是子序列，不要求顺序上是连续的。这样每次加入新元素的时候，前面的所有元素都有可能重新加入（或者退出）目标子序列，比如前面是 <code>[1,2,3,7,5]</code>，后面加入 6 的话，最优子序列就更新成 <code>[1,2,3,5,6]</code>。</p>
<p>dp 的含义为：<strong>当前元素加入后最优子序列的长度</strong> 。所以每次加入新元素还是要扫描前面所有情况。最后输出的结果要考虑全部元素加入后最大的那个长度。所以求一次最大值</p>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> maxNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; maxNum) maxNum = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>887. 鸡蛋掉落</title>
    <url>/posts/1142963852/</url>
    <content><![CDATA[<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<p>给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。</p>
<p>已知存在楼层 f ，满足 0 &lt;= f &lt;= n ，任何从 <strong>高于</strong> f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。</p>
<p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 &lt;= x &lt;= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 <strong>重复使用</strong> 这枚鸡蛋。</p>
<p>请你计算并返回要确定 f <strong>确切的值</strong> 的 <strong>最小操作次数</strong> 是多少？</p>
<span id="more"></span>
<h3 id="解答超时了"><a class="markdownIt-Anchor" href="#解答超时了"></a> 解答（超时了）</h3>
<p><strong>最小操作次数：</strong> 不管 f 取多少，我们采用的选取策略可以保证 <strong>多少次</strong> 以内定位到 f 的位置。也就是我们方法最差情况下消耗的次数（最好情况当然是 f 恰巧落在第一次选取的地方）</p>
<p>问题类似二分查找，区别在于鸡蛋如果落入临界点右区间就会碎掉，虽然二分查找效率比较高，但是我们试错的机会有限，所以必须采取保守一点的策略，确保任何 f 的取值都能顺利找到。</p>
<p><strong>注意：</strong> 只有鸡蛋在 i 和 i+1 层分别 <strong>不碎</strong> 和 <strong>碎</strong> 才能确定 f 的值（除非是 0 层 和 n层），所以大部分时候鸡蛋碎掉了标志着 f 找到。</p>
<h4 id="一个鸡蛋的情况"><a class="markdownIt-Anchor" href="#一个鸡蛋的情况"></a> 一个鸡蛋的情况</h4>
<p>如果只有一次机会，那么必须从 <strong>第一层</strong> 开始试验，一层一层往上直到碎掉。否则如果鸡蛋在中间某一层碎掉了，搜索就没办法继续了。所以 <strong>最小次数=n</strong>，可以看到为了防止鸡蛋破碎，查找的效率很低。</p>
<h4 id="两个鸡蛋的情况"><a class="markdownIt-Anchor" href="#两个鸡蛋的情况"></a> 两个鸡蛋的情况</h4>
<p>此时第一颗鸡蛋要从哪里起投就很复杂了，但至少我们知道：不管 <strong>1-楼层数</strong> 中间的哪个位置投下，只有两种结果（1）碎了（2）没碎。</p>
<p>（1）碎了说明投放的地方太高，我们就用剩下的一颗鸡蛋去左区间根据 <strong>一个鸡蛋的情况</strong> 搜索；</p>
<p>（2）没碎说明高度不够，我们就用剩下的两个鸡蛋去右区间迭代 <strong>两个鸡蛋的情况</strong> 搜索。</p>
<p>不管是（1）还是（2）都是已经解决的子问题，所以就可以转化成动态规划，最终 i 位置消耗的次数取（1）和（2）中较大的那个（因为考虑的是最坏情况）加上一（本次操作也要算上），我们需要计算 <strong>1-楼层数</strong> 间全部的可能，取次数最小的那个投放点即可。（这样导致时间消耗大）</p>
<p><strong>定义动态规划的状态：</strong> 在 <strong>i 个鸡蛋</strong> 的情况下，解决 <strong>j 层楼层</strong> 的问题的 <strong>最小操作次数</strong></p>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(k + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> minNum = n;</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k + <span class="number">1</span>; ++i) &#123;  <span class="comment">// k</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; ++j) &#123;  <span class="comment">// N</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;  <span class="comment">// 只有一个鸡蛋</span></span><br><span class="line">                    dp[i][j] = j;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                minNum = n;  <span class="comment">// 每次恢复 minNum</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= j; ++k)&#123;  <span class="comment">// 遍历取楼层 1-j，取次数最小的那个 k</span></span><br><span class="line">                    cur = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][k<span class="number">-1</span>], dp[i][j-k]) + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (cur &lt; minNum) minNum = cur;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = minNum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解答优化版"><a class="markdownIt-Anchor" href="#解答优化版"></a> 解答（优化版）</h3>
<p><strong>新的动态规划状态：</strong>  在 <strong>i 个鸡蛋</strong> 的情况下，解决 <strong>j 次操作</strong> 可以求解到的 <strong>最大楼层数</strong></p>
<h4 id="以两个鸡蛋的情况为例"><a class="markdownIt-Anchor" href="#以两个鸡蛋的情况为例"></a> 以两个鸡蛋的情况为例</h4>
<p>上个解答我们知道，投一个鸡蛋分为（1）碎了（2）没碎 两种结果，考虑在新的状态下，剩余 j 个次数，投第一个鸡蛋：</p>
<p>（1）碎了，投太高了，剩下一个鸡蛋去探索 <strong>j-1</strong> 次最多到达多少层；</p>
<p>（1）没碎，投太低了，剩下两个鸡蛋去探索 <strong>j-1</strong> 次最多到达多少层；</p>
<p>那么两个鸡蛋可以覆盖的层数就是 <strong>（1）+（2）+ 1</strong></p>
<p>不用管 <strong>第一个鸡蛋投在哪一层</strong>，可以把（1）和（2）看成是一个移动窗口，中心点在投的那层，当窗口通过移动中心点能够覆盖全部 N 层的时候，说明此时的 <strong>鸡蛋数目</strong> 和 <strong>操作次数</strong> 达到要求了。我们要做的就是从最简单的情况，不断推导到题目给定的 <strong>鸡蛋数目</strong> 和 <strong>操作次数</strong>。</p>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(k + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; ++j) &#123;  <span class="comment">// 最多 N 次肯定可以完成 N 层</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k + <span class="number">1</span>; ++i) &#123;  <span class="comment">// 从一个鸡蛋考虑到k个</span></span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[k][j] &gt;= n) <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>C++的vector</title>
    <url>/posts/415903961/</url>
    <content><![CDATA[<h3 id="什么是-vector"><a class="markdownIt-Anchor" href="#什么是-vector"></a> 什么是 vector</h3>
<p>vector 是一个动态大小的容器，具备很多功能。</p>
<span id="more"></span>
<h3 id="基本方法"><a class="markdownIt-Anchor" href="#基本方法"></a> 基本方法</h3>
<h4 id="创建一个-vector"><a class="markdownIt-Anchor" href="#创建一个-vector"></a> 创建一个 vector</h4>
<p>开头需要一行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>创建一个空 vector</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>从已有的 vector 创建拷贝：（两种方法等价）</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1 = v2;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(v2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>原型：<code>vector(const vector&amp;)</code>，复制构造函数</p>
</li>
<li>
<p>使用一个值填充 vector：（int 默认 0）</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span></span>;  <span class="comment">// 把初始值设置成 6</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>传入数组的首尾指针：（v2 只是拷贝 v1 的值，地址是新开辟的）</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(&amp;v1[<span class="number">0</span>], &amp;v1[v1.size()])</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 这里的首尾是左闭右开区间：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>b</mi><mi>e</mi><mi>g</mi><mi>i</mi><mi>n</mi><mo separator="true">,</mo><mi>e</mi><mi>n</mi><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[begin, end)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span>，所以第二个参数实际使用是 <strong>右边界+1</strong>。而且 <code>v.end()</code> 指向的是 vector 最后一个元素后面一位，所以正好是 <strong>右边界+1</strong>。</p>
</li>
</ol>
<h4 id="访问一个-vector"><a class="markdownIt-Anchor" href="#访问一个-vector"></a> 访问一个 vector</h4>
<p>定义一个迭代器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> iv = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// vector&lt;int&gt;::iterator iv = v.begin();</span></span><br><span class="line"><span class="keyword">for</span> (; iv &lt; v.<span class="built_in">end</span>(); iv++)</span><br><span class="line">  cout &lt;&lt; *iv &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 结果是：1 2 3</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 终止条件可以是小于 &lt; <code>v.end()</code>，也可以是不等于 <code>!= v.end()</code>。因为 end 指向的是 vector 最后一个元素还要后面的元素，所以当迭代器指向 end 的时候说明 vector 已经遍历结束了。</p>
<p>循环里面使用了迭代器，就不要给 vector 添加元素了（不然容器扩容会导致迭代器失效）</p>
]]></content>
  </entry>
  <entry>
    <title>C++的指针(和引用)</title>
    <url>/posts/3219915228/</url>
    <content><![CDATA[<h3 id="指针是什么"><a class="markdownIt-Anchor" href="#指针是什么"></a> 指针是什么</h3>
<ol>
<li><strong>指针</strong>是值为内存位置的变量。</li>
<li>每一个内存位置可使用连字号（&amp;）运算符访问。</li>
</ol>
<p><strong>ps：</strong> 现代的 C++ 程序应当尽量使用 vector 和迭代器，避免使用内置数组和指针；应当尽量使用 string，避免使用基于数组的字符串。</p>
<span id="more"></span>
<h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3>
<p>变量的两个维度：</p>
<ol>
<li>
<p>变量的值 <strong>（使用变量本身访问）</strong></p>
<ul>
<li>简单的比如整数变量 <code>int a = 3;</code>，那么直接用 <code>a</code> 就可以取到这个<strong>数值</strong>；</li>
<li>同样的道理，对于一个指针变量 <code>int *a</code>，<strong>它的值默认是内存中的某个地址</strong>，那么直接用 <code>a</code> 就可以取到这个地址（当然得到地址没什么用就是了）；</li>
<li>稍微复杂一点的是数组变量 <code>int a[3] = &#123;1,2,3&#125;</code>，单独的变量 <code>a</code> 并不会返回数组 <code>&#123;1,2,3&#125;</code>，而是数组首元素的地址（数组变量类似指针变量，虽然可以用 <code>a[0]</code> 来取出元素 <code>1</code>，但单独的它只是一个地址）</li>
</ul>
</li>
<li>
<p>变量的地址 <strong>（使用连字号 &amp; 访问）</strong></p>
<ul>
<li>简单的比如整数变量 <code>int a = 3;</code>，用 <code>&amp;a</code> 可以取到该整数变量在内存中的<strong>地址</strong>；</li>
<li>对于数组变量 <code>int a[3] = &#123;1,2,3&#125;</code>，用 <code>&amp;a[0]</code> 可以取到第 0 个元素在内存中的<strong>地址</strong>（其实它和数组变量 <code>a</code> 的值是相同的）；</li>
<li>指针变量 <code>int *a</code> 也存在 <code>&amp;a</code> 的写法，意思是<strong>指针变量的指针</strong>，毕竟指针变量也是变量，也会在内存中有一个位置。</li>
</ul>
</li>
</ol>
<p>指针变量还有另外一个维度：</p>
<ol>
<li>
<p>地址所在的值 <strong>（使用星号 * 访问）</strong></p>
<ul>
<li>
<p>指针变量存在的一个重要意义就是，可以挪动它指向的地方，从而灵活的操作内存中的变量。</p>
</li>
<li>
<p>下面的例子展示了，指针变量 p 是如何改变指向的位置并且读取位置上的值：</p>
</li>
<li>
<pre class="highlight"><code class="c++"><span class="hljs-keyword">int</span> x[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 一个整数数组</span>
<span class="hljs-keyword">int</span> *p;  <span class="hljs-comment">// 一个指针变量</span>
p = &amp;x[<span class="hljs-number">1</span>]  <span class="hljs-comment">// 让 p 指向 x[1] 的地址</span>
<span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 结果是：2（x[1]的值）</span>
&lt;!--code￼<span class="hljs-number">0</span>--&gt;

</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="数组指针"><a class="markdownIt-Anchor" href="#数组指针"></a> 数组指针</h3>
<ol>
<li>在赋值的时候，一个数组变量=数组首位元素的地址（这里是隐式转换的结果，数组变量在赋值给指针的时候自动变成首位地址）</li>
</ol>
<h4 id="容易搞错的地方"><a class="markdownIt-Anchor" href="#容易搞错的地方"></a> 容易搞错的地方</h4>
<p>虽然数组变量本身很像一个指针变量（因为是第一个元素的地址），但是最好不要（大概也不能）当成指针变量来用</p>
<p>可以逐个修改数组里面的元素，但是不能把其他地址的数组赋给已经有的数组变量了。</p>
<p>另外，指针变量必须指向已经存在于内存的变量地址（右边必须是变量），下面的情况数组还没建立，无法赋值给指针变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;  <span class="comment">// 错误的写法</span></span><br></pre></td></tr></table></figure>
<p>但是！字符串的场合又是可以的！因为右边字符串会先分配到内存，然后再是首位地址赋值给指针（所以为了避免混淆还是不要直接用数组/字符串赋值指针了吧）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *c = <span class="string">&quot;nihao&quot;</span>  <span class="comment">// 错误的写法</span></span><br><span class="line"><span class="comment">// warning: ISO C++11 does not allow conversion from string literal to &#x27;char *&#x27;</span></span><br></pre></td></tr></table></figure>
<p>总的来说，数组和字符串的地址应当是固定的，也就是说变量诞生到销毁指向的地址都是不应当改变的。</p>
<p>我们知道，给指针变量赋值数组首地址有两种写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">a = b;  <span class="comment">// 方法1</span></span><br><span class="line">a = &amp;b[<span class="number">0</span>] <span class="comment">// 方法2</span></span><br></pre></td></tr></table></figure>
<h4 id="多维数组"><a class="markdownIt-Anchor" href="#多维数组"></a> 多维数组</h4>
<p><strong>初始化：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">	&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">	&#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;,</span><br><span class="line">	&#123; <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;  <span class="comment">// 效果同上</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 全部初始化为0</span></span><br></pre></td></tr></table></figure>
<p><strong>遍历：</strong></p>
<p>首先二维数组其实是一个 <strong>指针的数组</strong>，指针是指向一个数组。以下是概念辨析：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p[<span class="number">4</span>];  <span class="comment">// 一个包含 4 个整型指针的数组</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">4</span>];  <span class="comment">// 一个指向含有 4 个整数的数组的指针变量</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 阅读方法是，把变量拎出来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为语法要求方括号在变量右边，我们阅读的时候可以拖到变量左边。</span></span><br><span class="line"><span class="keyword">int</span>*[<span class="number">4</span>] p;  <span class="comment">// 只是种阅读方式，不可以这样写</span></span><br><span class="line"><span class="keyword">int</span>[<span class="number">4</span>] (*p);  <span class="comment">// p 是一个指针，指向一个 4 个整数的数组</span></span><br></pre></td></tr></table></figure>
<p>上面 <strong>指向一个 4 个整数的数组的指针</strong> ，就是二维数组里面，第一层的元素。用指针去遍历它：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">4</span>] = ia; p &lt; ia + <span class="number">4</span>; p++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> *q = *p; q &lt; *p + <span class="number">3</span>; q++) &#123;</span><br><span class="line">        cout &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 第二个 for 里面 p 是 <strong>指向指针的指针</strong>，容易搞混，解指针还是指针！</p>
<p>方便的办法是用 auto：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p: ia) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;q: p) &#123;</span><br><span class="line">        cout &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然用下标访问也是可以的。</p>
<h4 id="总结一些常见用法"><a class="markdownIt-Anchor" href="#总结一些常见用法"></a> 总结一些常见用法</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1, *p2;</span><br><span class="line"><span class="keyword">int</span> x[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">p1 = &amp;x[<span class="number">0</span>];  <span class="comment">// 指向一个位置</span></span><br><span class="line">p2 = &amp;x[<span class="number">7</span>];</span><br><span class="line">*p1 = *(p2<span class="number">-1</span>);  <span class="comment">// *p1==7，赋值操作，*号取出来的变量</span></span><br></pre></td></tr></table></figure>
<h3 id="类的指针"><a class="markdownIt-Anchor" href="#类的指针"></a> 类的指针</h3>
<p>类的指针比较规范（不会出现数组和字符串那种奇奇怪怪的情况）</p>
<p>在定义一个类的指针，首先需要一个实例化的类：</p>
<h4 id="用-new-为类分配内存"><a class="markdownIt-Anchor" href="#用-new-为类分配内存"></a> 用 new 为类分配内存</h4>
<p>new 创建的对象返回指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;* p = <span class="keyword">new</span> vector&lt;<span class="keyword">int</span>&gt;();</span><br></pre></td></tr></table></figure>
<p>使用箭头运算符访问成员变量：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-tag">-</span>&gt;<span class="selector-tag">size</span>();</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-tag">-</span>&gt;<span class="selector-tag">empty</span>();</span><br><span class="line">(*p)<span class="selector-class">.empty</span>();  <span class="comment">// 等价于解开后的点运算符</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> new 对应的操作是 delete，但是 delete 只是清空指向的内存，指针本身并没有置空 nullptr，</p>
<h4 id="字符串的数组c11已废弃"><a class="markdownIt-Anchor" href="#字符串的数组c11已废弃"></a> 字符串的数组（c++11已废弃）</h4>
<p>字符串本身就是一个数组，所以字符串的数组应当是：<strong>指针变量的数组</strong></p>
<p>更新：定义指针的时候不要直接用未分配内存的字符串，这种方法不要用</p>
<p><strong>注意：</strong> 字符串变量虽然也是数组，但是可以直接交给 cout ，打印出来整个字符串（而不是首元素地址）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *names[] = &#123;</span><br><span class="line">                   <span class="string">&quot;Zara Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Hina Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Nuha Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Sara Ali&quot;</span>,</span><br><span class="line">   			   &#125;;</span><br><span class="line">cout &lt;&lt; names[<span class="number">0</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="引用是什么"><a class="markdownIt-Anchor" href="#引用是什么"></a> 引用是什么</h3>
<p>一般的赋值，都是值拷贝（修改副本影响不到本体）。下面的例子展示了值拷贝，如果 <strong>a = a + 1</strong> 右边赋给的不是值，而是地址，那会有一个无限迭代（不然 a 永远是 上一个 a 再 + 1）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">a = a + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>引用也可以解决地址拷贝的问题（另一个方法是指针），引用变量就是 a 的替身</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br><span class="line">b = <span class="number">2</span>;  <span class="comment">// a 也跟着变成 2</span></span><br></pre></td></tr></table></figure>
<h4 id="传参的时候用引用"><a class="markdownIt-Anchor" href="#传参的时候用引用"></a> 传参的时候用引用</h4>
<p>函数传参进来，默认是值拷贝，从调用的地方把值复制一遍传给函数。函数内部对我们的变量做了任何改动都影响不到外面的本体了</p>
<p>如果我们需要在函数里面影响到传进来的参数本身（比如修改数组的成员），就要把形参改成引用。</p>
<p><strong>swap的例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修改数组元素的例子：</strong></p>
<p>函数传入一个数组的引用，返回数组某个元素的引用。</p>
<p><strong>注意：</strong> 函数类型也是引用，引用的定义必须有等号初始化（不能空引用）。传参的时候也必须是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误写法，即使返回引用，也修改不到原来的nums</span></span><br><span class="line"><span class="comment">// int&amp; setValue(vector&lt;int&gt; nums, int i) &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">setValue</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>&amp; x = nums[i];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">setValue</span>(nums, <span class="number">0</span>) = <span class="number">8</span>;  <span class="comment">// 返回引用就可以修改这个元素啦</span></span><br></pre></td></tr></table></figure>
<p>总之，引用就是为了解决传参和出参总是产生副本的问题。（ <strong>从值传递变成引用传递</strong> ）</p>
<p>当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。</p>
]]></content>
  </entry>
  <entry>
    <title>C++的string</title>
    <url>/posts/2635778603/</url>
    <content><![CDATA[<h3 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">string s1;</span><br><span class="line">string s2 = <span class="string">&quot;abc&quot;</span>;  <span class="comment">// char* 自动转换，这是 string 定义的转换</span></span><br><span class="line">string s3 = s2;</span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(s3)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;  <span class="comment">// n 个重复的 char</span></span><br></pre></td></tr></table></figure>
<p><strong>拷贝初始化：</strong> 用等于号初始化，右边的 string 是先初始化出来，再赋值拷贝给左边的。</p>
<p><strong>直接初始化：</strong> 直接括号初始化。</p>
<h3 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s[n];</span><br><span class="line">s1 + s2;  <span class="comment">// 合并</span></span><br><span class="line">s.<span class="built_in">empty</span>();</span><br><span class="line">s.<span class="built_in">length</span>();</span><br><span class="line">s1 == s2;   <span class="comment">// 判断值相等</span></span><br><span class="line"><span class="built_in">getline</span>(is, s);  <span class="comment">// is: in stream, \n</span></span><br><span class="line">is &gt;&gt; s;  <span class="comment">// \s</span></span><br></pre></td></tr></table></figure>
<h4 id="输入运算符"><a class="markdownIt-Anchor" href="#输入运算符"></a> &gt;&gt; 输入运算符</h4>
<p>前面的输入 is 一直到空格停止，赋值给后面的变量 s</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; s1 &gt;&gt; s2;</span><br></pre></td></tr></table></figure>
<p>一个输入运算符赋值一次，所以如果 cin 是 “Hello World”，那么 s1 和 s2 分别被赋值 “Hello” 和 “World”。</p>
<p>cin 读入失败以后，自动转换成布尔值 false，退出循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (cin &gt;&gt; s) &#123;&#125;  \\ 每次读取一个单词</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(cin, s)) &#123;&#125;  \\ 每次读取一行</span><br></pre></td></tr></table></figure>
<h3 id="转换"><a class="markdownIt-Anchor" href="#转换"></a> 转换</h3>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">stoi  <span class="regexp">//</span> 转成 int</span><br><span class="line">stof  <span class="regexp">//</span> 转成 float</span><br><span class="line">stod  <span class="regexp">//</span> 转成 float</span><br><span class="line">to_string  <span class="regexp">//</span> 其他类型转成 string</span><br><span class="line">(char*)string.data();  <span class="regexp">//</span> string转化成char数组</span><br><span class="line">(char*)string.c_str();  <span class="regexp">//</span> 同上</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3>
<p><strong>split：</strong> string 没有提供 split</p>
<p><strong>std::string::npos：</strong> 和 string.find 配套使用，如果没找到返回的就是 npos。如果 using 了 std 命名空间，那么只需要 string::pos 即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> string &amp;s, string delimiter)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string to_split = s;  <span class="comment">// 拷贝</span></span><br><span class="line">    <span class="keyword">int</span> pos = to_split.<span class="built_in">find</span>(delimiter);  <span class="comment">// find找到的是最前面的delimiter位置</span></span><br><span class="line">    <span class="keyword">int</span> delimiter_size = delimiter.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">while</span> (pos != std::string::npos) &#123;  <span class="comment">// npos</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(to_split.<span class="built_in">substr</span>(<span class="number">0</span>, pos));</span><br><span class="line">        to_split = to_split.<span class="built_in">substr</span>(pos + delimiter.<span class="built_in">length</span>(), to_split.<span class="built_in">length</span>() - <span class="number">1</span>);</span><br><span class="line">        pos = to_split.<span class="built_in">find</span>(delimiter);</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="built_in">push_back</span>(to_split);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">split</span>(<span class="string">&quot;123,234&quot;</span>, <span class="string">&quot;,&quot;</span>);  <span class="comment">// char* 会被自动转化成string</span></span><br></pre></td></tr></table></figure>
<p>如果 delimiter 是单个字符，把字符串转换成 stringstream，然后用 getline 也可以。不过 getline 的第三个参数 delimiter 需要是 char。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="function">stringstream <span class="title">is</span><span class="params">(str_to_split)</span></span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(is, s, <span class="string">&#x27;,&#x27;</span>)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="string作为参数"><a class="markdownIt-Anchor" href="#string作为参数"></a> string作为参数</h3>
<p>即使调用函数给的是 “123212” 这种，也会自动识别转换为 string。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(string x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">func</span>(<span class="string">&quot;1234&quot;</span>);  <span class="comment">// 这样是可以的</span></span><br></pre></td></tr></table></figure>
<p>但是如果形参是这样的，又不行了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fuc</span><span class="params">(string&amp; x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; x;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">func</span>(<span class="string">&quot;1234&quot;</span>);  <span class="comment">// 报错 const char [4] 不能自动转成 string</span></span><br></pre></td></tr></table></figure>
<p>看来，“1232” 这种实际上是 <strong>const char []</strong> 类型的</p>
<p><strong>string的特性</strong></p>
<p>string 和<code>char *</code>类型的字符串进行对比：<br>
（1）<code>char *</code>是一个指针，而string是一个类。string封装了<code>char *</code>，管理这个字符串，是一个<code>char *</code>型的容器。<br>
（2）string封装了很多实用的成员方法。查找find，拷贝copy，删除delete，替换replace和插入insert等<br>
（3）string不用考虑内存释放和越界问题。string管理<code>char *</code>所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。</p>
]]></content>
  </entry>
  <entry>
    <title>C++的类</title>
    <url>/posts/2545696309/</url>
    <content><![CDATA[<p>c++类的一些基本用法</p>
<span id="more"></span>
<h3 id="实例成员"><a class="markdownIt-Anchor" href="#实例成员"></a> 实例成员</h3>
<p>把 A 当成结构体来用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line">&#125;;  <span class="comment">// 结尾有分号</span></span><br></pre></td></tr></table></figure>
<p>实例化一个类有两种办法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A* a1 = <span class="keyword">new</span> <span class="built_in">A</span>();  <span class="comment">// 用 new 创建指针</span></span><br><span class="line">    cout &lt;&lt; a1-&gt;x;</span><br><span class="line">    A a2 = <span class="built_in">A</span>();  <span class="comment">// 直接创建</span></span><br><span class="line">    cout &lt;&lt; a2.x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h3>
<p>构造函数和类的名称一样，不需要声明类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">A</span>() &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A* a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">cout &lt;&lt; a-&gt;x;  <span class="comment">// 结果是 x+1 = 4</span></span><br></pre></td></tr></table></figure>
<p>也可以现在 public 里面声明，然后再在外面定义构造函数</p>
<p><strong>注意：</strong> 声明构造函数用分号结尾，定义用花括号结尾</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">A</span>();</span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="built_in">A</span>() &#123;</span><br><span class="line">    ++x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>初始化列表：</strong> 构造函数还可以为其他成员变量初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> i);</span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="keyword">int</span> i): <span class="built_in">x</span>(i) &#123;  <span class="comment">// 把输入的参数 i 同时用来初始化成员 x 了</span></span><br><span class="line">    ++x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的相当于：（把构造函数挪到类里也是一样的）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A::<span class="built_in">A</span>(<span class="keyword">int</span> i): &#123;</span><br><span class="line">    x = i;</span><br><span class="line">    ++x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="析构函数"><a class="markdownIt-Anchor" href="#析构函数"></a> 析构函数</h3>
<p>和构造函数的区别就是，释放内存的时候执行的函数，同样不需要返回值，加个波浪号就行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>() &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;A is born&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;;</span><br><span class="line">        ~<span class="built_in">A</span>() &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;A is over&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// A::~A() &#123;&#125; 的定义也可以</span></span><br><span class="line"></span><br><span class="line">A* a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line"><span class="keyword">delete</span> a;</span><br></pre></td></tr></table></figure>
<h3 id="拷贝构造函数"><a class="markdownIt-Anchor" href="#拷贝构造函数"></a> 拷贝构造函数</h3>
<p>和构造函数的区别就是，它需要传入一个 const 版本的实例化的自己的引用</p>
<p>定义了这个函数，就可以 <strong>类名(实例名)</strong> 初始化一个新的类。</p>
<p>拷贝构造函数发生的情形：</p>
<p>1、对象被值传递的传参进函数（引用传递就不会调用拷贝构造函数了）</p>
<p>2、对象被返回为值出函数（返回类型是引用不会调用拷贝）</p>
<p>3、初始化新的对象时</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">const</span> A&amp; a) &#123;  <span class="comment">// 这个传入 const 类名引用 参数名 的就是拷贝构造函数</span></span><br><span class="line">            x = a.x;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">A a;</span><br><span class="line">a.x = <span class="number">100</span>;</span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">cout &lt;&lt; b.x;</span><br></pre></td></tr></table></figure>
<p>为什么加 const：加不加差不多，但是可以防止意外的修改。（拷贝的过程只读即可）</p>
<p>为什么要加引用呢，如果直接传类本身进 <strong>拷贝构造函数</strong>，会触发函数传参规则的 <strong>值传递拷贝</strong>，导致再次调用 <strong>拷贝构造函数</strong>，形成无限递归了。</p>
<h3 id="public-和-private"><a class="markdownIt-Anchor" href="#public-和-private"></a> public 和 private</h3>
<p>public、private（还有protected）的目的主要是为了继承</p>
<p><strong>public：</strong> 类里面全部可以互通，大家都有读写权限。</p>
<p><strong>private：</strong> 只有类函数的 <strong>里面</strong> 可以拿到 private 变量与函数的操作（读写）权限，其他情况都是无权限的（省得用户乱改）</p>
]]></content>
  </entry>
  <entry>
    <title>Rmarkdown里面的表格</title>
    <url>/posts/1527658047/</url>
    <content><![CDATA[<h2 id><a class="markdownIt-Anchor" href="#"></a> </h2>
]]></content>
  </entry>
  <entry>
    <title>剑指 Offer 48. 最长不含重复字符的子字符串</title>
    <url>/posts/2263724427/</url>
    <content><![CDATA[<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/</a></p>
<span id="more"></span>
<h3 id="解答队列"><a class="markdownIt-Anchor" href="#解答队列"></a> 解答（队列）</h3>
<p>遍历一遍字符串即可，不断的往队列添加字符并记录最大长度。</p>
<p>还要确保队列里面都是没有重复的字符，做法是一旦下一位出现了重复的字符 s，就要截掉队列前半部分，直到队列没有那个 s，再加入下一位 s。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        deque&lt;<span class="keyword">char</span>&gt; cur;</span><br><span class="line">        <span class="keyword">char</span> curString;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            curString = s[i];</span><br><span class="line">            <span class="comment">// 每次加新元素判断已经存在</span></span><br><span class="line">            <span class="comment">// 存在的话去掉头部元素直到没有重复元素</span></span><br><span class="line">            <span class="keyword">while</span> (!cur.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">find</span>(cur.<span class="built_in">begin</span>(), cur.<span class="built_in">end</span>(), curString) != cur.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                cur.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur.<span class="built_in">push_back</span>(curString);</span><br><span class="line">            <span class="keyword">if</span> (cur.<span class="built_in">size</span>() &gt; maxLen) maxLen = cur.<span class="built_in">size</span>();  <span class="comment">// 更新最大长度</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解答动态规划"><a class="markdownIt-Anchor" href="#解答动态规划"></a> 解答（动态规划）</h3>
<p>思路和队列法类似，<code>dp[i]</code> 表示以 <strong>第 i 个字符</strong> 为结尾的最长无重复字符串的长度，分为两种情况：</p>
<ol>
<li>如果扫描 <code>dp[i-1]</code> 的字符串（也就是 <strong>第 i -1个字符</strong> 为结尾的目标字符串）里面没有 <code>s[i]</code>，此时直接把 <code>s[i]</code> 加入候补字符串，所以 <code>dp[i] = dp[i-1] + 1</code>；</li>
<li>如果扫描 <code>dp[i-1]</code> 的字符串发现了已经有  <code>s[i]</code> 在里面（发生重复），那么就要记录下重复点的位置，更新重复点之后直到 i 位置的子字符串才是 i 位置的长度。（首先 i-1 位置是确保没有重复的，那么排除了里面和 <code>s[i]</code> 重复的，剩下的即可计入 i 位置的长度）。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> curMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> update;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            update = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; i - dp[i<span class="number">-1</span>] - <span class="number">1</span>; j--) &#123;  <span class="comment">// dp[i-1]状态是否含有 s[i]</span></span><br><span class="line">                <span class="keyword">if</span> (s[j] == s[i]) &#123;  <span class="comment">// 更新长度</span></span><br><span class="line">                    dp[i] = i - j;</span><br><span class="line">                    update = <span class="literal">true</span>;  <span class="comment">// 发现有重复</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; curMax) curMax = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>剑指 Offer 53 - I. 在排序数组中查找数字 I</title>
    <url>/posts/3603375374/</url>
    <content><![CDATA[<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<p>统计一个数字在排序数组中出现的次数。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/</a></p>
<span id="more"></span>
<p><strong>注意：</strong> nums 是非递减的，target 不在里面或者 nums 为空的时候返回 0。</p>
<p><img src="/posts/3603375374/image-20220301161408384.png" alt="image-20220301161408384"></p>
<h3 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h3>
<p>主要思路是：通过二分法找到目标，考虑到数组里可能存在多个目标，需要分别二分查找到 <strong>目标的下界（数组里目标的最小下标）</strong> 和 <strong>目标的上界（数组里目标的最大下标）</strong>，然后把上下界相减补一即为目标的个数。</p>
<h4 id="目标下界查找"><a class="markdownIt-Anchor" href="#目标下界查找"></a> 目标下界查找</h4>
<p>首先查找下界，回顾一般的二分查找一个数的思路，每次访问中间点的值，进行如下判断直到左右边界重叠（表示收缩边界完毕找到了）：</p>
<ol>
<li>如果大于目标，设为右边界 <code>j</code>；</li>
<li>如果等于目标，直接返回找到；</li>
<li>如果小于目标，设为左边界 <code>i</code>。</li>
</ol>
<p>回到问题，需要对二分查找进行扩展。情况一和情况三都不需要修改，因为此时还没找到目标值，可以放心的收缩边界。只有情况二的时候需要讨论，究竟是把中间点重设成左边界还是右边界？</p>
<p>结论：应当是右边界。因为查找目标的下界是这样一个过程：我们要求左边界只要搜索到目标左隔壁元素（也就是小于目标最大那个值）就停止更新了（因为剩下的元素不可能再比目标小了），这种情况如果中间点的值等于目标，我们也要他去收缩右边界，不可以动左边界了。（最后返回左边界即为目标的下界）</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt;= j)&#123;</span><br><span class="line">    mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt;= target)</span><br><span class="line">        j = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">        i = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">l = i;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 终止条件带等号，是因为每次更新边界都会在 mid 的基础上调整一位，</p>
<p>举例：<code>nums = [0,0], target = 2, mid = 0</code>，如果终止条件不加等号，此时更新后的左右边界在 1 处重合，但此时找到的实际上含义是 <strong>数组里小于target且下标最大的元素</strong>，可是我们的最终找的是目标的下界（他应该是 <strong>数组里小于target最大的下标加一</strong>）。终止条件不加等号处理，会导致最后找出来的目标的上下界重合（而不是上界=下界-1，因为目标不再数组内）</p>
<h4 id="下界查找例子"><a class="markdownIt-Anchor" href="#下界查找例子"></a> 下界查找例子</h4>
<p>以 <code>nums = [5,7,7,8,8,10], target = 8</code> 为例：</p>
<table>
<thead>
<tr>
<th>5</th>
<th>7</th>
<th>7</th>
<th>8</th>
<th>8</th>
<th>10</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>二分下标 <code>mid = 2</code>，<code>nums[mid] = 7</code>，根据情况三，左边界从 0 更新到 3：（左边界已经定下来了，不可能再更新了）</p>
<p><strong>注意：</strong> 这里直接把左边界在 mid 的基础上加一，因为 mid 的值本身就小于 target，所以可以直接跳过排除。</p>
<table>
<thead>
<tr>
<th>5</th>
<th>7</th>
<th><u>7</u></th>
<th>8</th>
<th>8</th>
<th>10</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>二分下标 <code>mid = 4</code>，<code>nums[mid] = 8</code>，根据情况二，右边界从 5 更新到 3：</p>
<table>
<thead>
<tr>
<th><s>5</s></th>
<th><s>7</s></th>
<th><s>7</s></th>
<th><u>8</u></th>
<th>8</th>
<th>10</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>可以看到此时左右边界重合，实质上查找已经结束，但还是需要迭代一次直到终止条件达到，返回左边界即可。</p>
<h4 id="目标上界查找"><a class="markdownIt-Anchor" href="#目标上界查找"></a> 目标上界查找</h4>
<p>上界的查找可以基于下界的思路，最终的目的是找到 <strong>target右侧最小的小标 - 1</strong>，换句话说它一定就是目标的上界了。</p>
<p>需要修改的地方就是中间点等于目标的情况，这时是要收缩左边界，直到找到 **target右侧最小的小标 **。</p>
<p>翻译成代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">    mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">        j = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt;= target)</span><br><span class="line">        i = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">r = i - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>以 <code>nums = [5,7,7,8,8,10], target = 8</code> 为例：</p>
<table>
<thead>
<tr>
<th>5</th>
<th>7</th>
<th>7</th>
<th>8</th>
<th>8</th>
<th>10</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>二分下标 <code>mid = 2</code>，<code>nums[mid] = 7</code>，根据情况三，左边界从 0 更新到 3：</p>
<table>
<thead>
<tr>
<th>5</th>
<th>7</th>
<th><u>7</u></th>
<th>8</th>
<th>8</th>
<th>10</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>二分下标 <code>mid = 4</code>，<code>nums[mid] = 8</code>，左边界从 3 更新到 5：</p>
<table>
<thead>
<tr>
<th><s>5</s></th>
<th><s>7</s></th>
<th><s>7</s></th>
<th>8</th>
<th><u>8</u></th>
<th>10</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>可以看到此时左右边界重合，实质上查找已经结束，但还是需要迭代一次直到终止条件达到，返回左边界-1即可。</p>
]]></content>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/posts/2276098981/</url>
    <content><![CDATA[<h2 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h2>
<h3 id="堆是什么"><a class="markdownIt-Anchor" href="#堆是什么"></a> 堆是什么</h3>
<ol>
<li>堆是完全二叉树</li>
<li>堆的每个结点都小于（或大于）父结点的值</li>
</ol>
<h3 id="堆排序是什么"><a class="markdownIt-Anchor" href="#堆排序是什么"></a> 堆排序是什么</h3>
<ol>
<li>构建大顶堆（根结点是最大元素的堆）</li>
<li>交换根结点和最后一个结点，最大元素移到数组末尾固定下来</li>
<li>继续重复构建前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个元素的大顶堆，直到只剩下根结点没有固定</li>
</ol>
<span id="more"></span>
<h3 id="和选择排序的区别"><a class="markdownIt-Anchor" href="#和选择排序的区别"></a> 和选择排序的区别</h3>
<p>选择排序的每轮迭代也是从剩下的元素中挑出最小的那个固定下来，堆排序的优点在于，每次迭代会利用到之前的信息，因为建堆完后的二叉树从上到下可以保证大体上是由大到小的，在每次首尾交换之后，重新恢复建堆只需要大约 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 次交换，相比选择排序需要扫描所有元素。</p>
<h2 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h2>
<h3 id="建堆"><a class="markdownIt-Anchor" href="#建堆"></a> 建堆</h3>
<ol>
<li>
<p>从最后一个非叶子结点（父结点）开始，把它和它的左右结点（如果有）中最大的放到当前位置上。执行这个过程直到根结点</p>
<ul>
<li>如果根结点下标从 0 开始记，当前结点如果是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，那么它的左结点是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，右结点是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2i+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></li>
<li>如果根结点下标从 1 开始记，当前结点如果是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，那么它的左结点是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>i</mi></mrow><annotation encoding="application/x-tex">2i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span></span></span></span>，右结点是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
</ul>
<p>以上关系表明，获取子结点的父亲的办法是：</p>
<ul>
<li>如果根结点下标从 0 开始记，当前结点减 1 整除 2（也就是，下标 1 版本需要减 2 再整除 2）</li>
<li>如果根结点下标从 1 开始记，当前结点整除 2</li>
</ul>
<p><strong>备注：</strong> 数组长度 length：下标从 1 开始记</p>
</li>
</ol>
<h3 id="备注"><a class="markdownIt-Anchor" href="#备注"></a> 备注</h3>
<ol>
<li></li>
</ol>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
  </entry>
  <entry>
    <title>接雨水</title>
    <url>/posts/1726193520/</url>
    <content><![CDATA[<p>两个接雨水题目，都用双指针做。</p>
<h3 id="11-盛最多水的容器"><a class="markdownIt-Anchor" href="#11-盛最多水的容器"></a> 11. 盛最多水的容器</h3>
<p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p>
<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p>说明：你不能倾斜容器。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/container-with-most-water/">https://leetcode-cn.com/problems/container-with-most-water/</a></p>
<img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img" style="zoom:67%;">
<span id="more"></span>
<h3 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h3>
<p>双指针法，根据木桶原理，当前容量取决于 <strong>间隔 * 短板长度</strong> ，为了使容量尽可能往大的方向前进，不可能先动长板（因为高度被短板制约），所以每次指针在短板处移动一格，并记录一下当前容量和最大容量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="built_in">min</span>(height[<span class="number">0</span>], height[j]);</span><br><span class="line">        maxNum = h * (j - i);</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[j] &lt; height[i]) &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            h = <span class="built_in">min</span>(height[i], height[j]);</span><br><span class="line">            <span class="keyword">if</span> ((j - i) * h &gt; maxNum) maxNum = (j - i) * h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="42-接雨水"><a class="markdownIt-Anchor" href="#42-接雨水"></a> 42. 接雨水</h3>
<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<img src="/posts/1726193520/image-20220307213203323.png" alt="image-20220307213203323" style="zoom:50%;">
<blockquote>
<p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>
输出：6<br>
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p>
</blockquote>
<h3 id="解答-2"><a class="markdownIt-Anchor" href="#解答-2"></a> 解答</h3>
<p>同样是木桶原理，只不过这里木板本身会占用桶内的体积（上一题木板是没有体积的），所以容量的计算要随着指针前进一起，前进的方向还是跟着短板走，下一块板可能有两种情况：</p>
<p>（1）比短板矮，说明可以接水，容量加上 <strong>短板高度 - 下一块板高度</strong>；</p>
<p>（2）比短板高，重新决定哪块是短板。</p>
<p>如果左右指针高度一样，随便哪个方向都行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftLength = height[<span class="number">0</span>];  <span class="comment">// 左右板长度</span></span><br><span class="line">        <span class="keyword">int</span> rightLength = height[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i] &lt; height[j]) &#123;  <span class="comment">// 短板在左边</span></span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">if</span> (height[i] &gt; leftLength) &#123;</span><br><span class="line">                    leftLength = height[i];  <span class="comment">// 更新左板长度</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans += leftLength - height[i];  <span class="comment">// 可以加雨水</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;  <span class="comment">// 短板在右边</span></span><br><span class="line">                --j;</span><br><span class="line">                <span class="keyword">if</span> (height[j] &gt; rightLength) &#123;</span><br><span class="line">                    rightLength = height[j];  <span class="comment">// 更新右板长度 </span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans += rightLength - height[j];  <span class="comment">// 可以加雨水</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>剑指 Offer 59 - I. 滑动窗口的最大值</title>
    <url>/posts/2941832896/</url>
    <content><![CDATA[<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/</a></p>
<p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p>
<span id="more"></span>
<p><strong>示例:</strong></p>
<p><img src="/posts/2941832896/image-20220223002214227.png" alt="image-20220223002214227"></p>
<p><strong>提示：</strong></p>
<p>你可以假设 <em>k</em> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p>
<h3 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h3>
<h3 id="暴力法"><a class="markdownIt-Anchor" href="#暴力法"></a> 暴力法</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - k + <span class="number">1</span>):</span><br><span class="line">            res.append(<span class="built_in">max</span>(nums[i:i+k]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="维护一个队列"><a class="markdownIt-Anchor" href="#维护一个队列"></a> 维护一个队列</h3>
<p>类似于 <strong>剑指 Offer 30. 包含min函数的栈</strong>，里面维护了一个记录最小值的栈。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/</a></p>
<p>为什么需要一个队列：</p>
<ul>
<li>先进去的元素随着窗口往后先出去，只用来记录一些可能成为最大值的元素，不会比当前窗口更长</li>
</ul>
<p>每次滑动一格窗口，更新最大值候补队列，有以下可能：</p>
<ol>
<li>
<p><strong>新元素肯定成为候补：</strong></p>
<ol>
<li>新元素大于上个窗口的最大值，直接清空队列并加入新元素（因为新元素之前的所有元素都不可能成为最大值了，新元素肯定比他们活得久）</li>
<li>新元素小于上个窗口的最大值，他也需要加入队列（因为随着窗口往后移动，它总有一天会变成队首，所以它要作为候补加入）</li>
</ol>
<ul>
<li>换句话说，队首元素一定是队列里最大的（不然新加入的会取而代之），每次移动被加入 result 的一定是队首。</li>
</ul>
</li>
<li>
<p><strong>上个窗口的首位元素要被滑过：</strong></p>
<ol>
<li>上个窗口的首尾元素就是上个窗口的最大值（队首），那么队首要被弹出</li>
</ol>
</li>
<li>
<p><strong>队列中已有的元素可能被新元素取代：</strong></p>
<ol>
<li>新元素可以把队列中从尾部到首部所有小于它的元素取代（因为新元素大于他们且活的更久）</li>
</ol>
</li>
</ol>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        maxQueue = [nums[<span class="number">0</span>]]</span><br><span class="line">        <span class="comment"># 前k个不需要考虑首位弹出的情况</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; maxQueue[<span class="number">0</span>]: <span class="comment"># 大的新元素直接清空</span></span><br><span class="line">                maxQueue = []</span><br><span class="line">            <span class="keyword">while</span> maxQueue <span class="keyword">and</span> maxQueue[-<span class="number">1</span>] &lt; nums[i]:  </span><br><span class="line">                <span class="comment"># 如果上一步清空就跳过</span></span><br><span class="line">                <span class="comment"># 加入新元素时取代一些旧的</span></span><br><span class="line">                maxQueue.pop()</span><br><span class="line">            maxQueue.append(nums[i])  <span class="comment"># 新元素一定会入队列</span></span><br><span class="line">        res.append(maxQueue[<span class="number">0</span>])  <span class="comment"># 前k个扫描完毕后提交一次最大值</span></span><br><span class="line">        <span class="comment"># 剩下的考虑首位出队列的情况</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, n):</span><br><span class="line">            <span class="built_in">print</span>(maxQueue)</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; maxQueue[<span class="number">0</span>]: <span class="comment"># 大的新元素直接清空</span></span><br><span class="line">                maxQueue = []</span><br><span class="line">            <span class="keyword">elif</span> nums[i - k] == maxQueue[<span class="number">0</span>]:  <span class="comment"># 首位是最大元需要弹出</span></span><br><span class="line">                maxQueue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">while</span> maxQueue <span class="keyword">and</span> maxQueue[-<span class="number">1</span>] &lt; nums[i]:</span><br><span class="line">                <span class="comment"># 如果上一步清空就跳过</span></span><br><span class="line">                <span class="comment"># 加入新元素时取代一些旧的</span></span><br><span class="line">                maxQueue.pop()</span><br><span class="line">            maxQueue.append(nums[i])  <span class="comment"># 新元素一定会入队列</span></span><br><span class="line">            res.append(maxQueue[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2>
<p>相似题目：</p>
<ul>
<li>
<p><strong>剑指 Offer 59 - II. 队列的最大值</strong></p>
<p><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/</a></p>
</li>
<li>
<p><strong>剑指 Offer 30. 包含min函数的栈</strong></p>
<p><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/</a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>面试速成</title>
    <url>/posts/2499817694/</url>
    <content><![CDATA[<p>来不及了，速成决策树</p>
<h3 id="决策树"><a class="markdownIt-Anchor" href="#决策树"></a> 决策树</h3>
<h3 id="cart"><a class="markdownIt-Anchor" href="#cart"></a> CART</h3>
<p>Classification And Regression Tree (CART)，顾名思义，又可以回归又可以分类</p>
<p>树结构，每次分裂记录：（1）哪个特征（2）分裂点（3）输出值。终止条件到达后，结点变为叶子，里面的值是 y 的 <strong>均值（回归）</strong> 或者 <strong>概率（分类）</strong>。预测的时候对每个输入样本走一遍遍历</p>
<h3 id="gbdt"><a class="markdownIt-Anchor" href="#gbdt"></a> GBDT</h3>
<p>boosting 用在 CART 树上面</p>
<p>输出就是一层层的模型输出值加权，分类输出概率（取大的作为类别），回归直接输出预测值</p>
<p><strong>CART：</strong></p>
<p><strong>GBDT：</strong></p>
<p><strong>RF：</strong></p>
<p><strong>Adaboost</strong>：</p>
]]></content>
  </entry>
</search>
