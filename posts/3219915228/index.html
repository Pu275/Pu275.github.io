<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0"><link rel="preconnect" href="https//fonts.lug.ustc.edu.cn" crossorigin><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/head.jpg"><link rel="icon" type="image/png" sizes="32x32" href="/images/head.jpg"><link rel="icon" type="image/png" sizes="16x16" href="/images/head.jpg"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="baidu-site-verification" content="code-iieqrRhDAh"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"puhan.top","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":25,"offset":20},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":true,"nav":null,"activeClass":"valine"},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="指针是什么  指针是值为内存位置的变量。 每一个内存位置可使用连字号（&amp;）运算符访问。  ps： 现代的 C++ 程序应当尽量使用 vector 和迭代器，避免使用内置数组和指针；应当尽量使用 string，避免使用基于数组的字符串。"><meta property="og:type" content="article"><meta property="og:title" content="C++的指针(和引用)"><meta property="og:url" content="https://puhan.top/posts/3219915228/index.html"><meta property="og:site_name" content="陈涵的博客"><meta property="og:description" content="指针是什么  指针是值为内存位置的变量。 每一个内存位置可使用连字号（&amp;）运算符访问。  ps： 现代的 C++ 程序应当尽量使用 vector 和迭代器，避免使用内置数组和指针；应当尽量使用 string，避免使用基于数组的字符串。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-02-27T15:48:43.000Z"><meta property="article:modified_time" content="2022-03-29T12:02:56.056Z"><meta property="article:author" content="陈涵"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://puhan.top/posts/3219915228/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://puhan.top/posts/3219915228/","path":"posts/3219915228/","title":"C++的指针(和引用)"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++的指针(和引用) | 陈涵的博客</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">陈涵的博客</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-分类"><a href="/cate/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">指针是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="nav-text">数组指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E6%98%93%E6%90%9E%E9%94%99%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="nav-text">容易搞错的地方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8new%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="nav-text">用new创建数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-text">多维数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%A0%E5%8F%82"><span class="nav-text">数组的传参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95"><span class="nav-text">总结一些常见用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-text">类的指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8-new-%E4%B8%BA%E7%B1%BB%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-text">用 new 为类分配内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%BB%84c11%E5%B7%B2%E5%BA%9F%E5%BC%83"><span class="nav-text">字符串的数组（c++11已废弃）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">引用是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E5%8F%82%E7%9A%84%E6%97%B6%E5%80%99%E7%94%A8%E5%BC%95%E7%94%A8"><span class="nav-text">传参的时候用引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98"><span class="nav-text">内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C-const"><span class="nav-text">指针和 const</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E6%A8%A1%E6%9D%BF"><span class="nav-text">重载和模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="nav-text">显示特例化</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="陈涵" src="/images/head.jpg"><p class="site-author-name" itemprop="name">陈涵</p><div class="site-description" itemprop="description">没有关系</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">42</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div></nav></div><div class="cc-license site-overview-item animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://puhan.top/posts/3219915228/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><a href="/"><img class="site-author-image" itemprop="image" src="/%5Bobject%20Object%5D" alt=""></a><meta itemprop="image" content="/images/head.jpg"><meta itemprop="name" content="陈涵"><meta itemprop="description" content="没有关系"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="陈涵的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">C++的指针(和引用)</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-02-27 23:48:43" itemprop="dateCreated datePublished" datetime="2022-02-27T23:48:43+08:00">2022-02-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-03-29 20:02:56" itemprop="dateModified" datetime="2022-03-29T20:02:56+08:00">2022-03-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/posts/3219915228/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/posts/3219915228/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="指针是什么"><a class="markdownIt-Anchor" href="#指针是什么"></a> 指针是什么</h3><ol><li><strong>指针</strong>是值为内存位置的变量。</li><li>每一个内存位置可使用连字号（&amp;）运算符访问。</li></ol><p><strong>ps：</strong> 现代的 C++ 程序应当尽量使用 vector 和迭代器，避免使用内置数组和指针；应当尽量使用 string，避免使用基于数组的字符串。</p><span id="more"></span><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><p>变量的两个维度：</p><ol><li><p>变量的值 <strong>（使用变量本身访问）</strong></p><ul><li>简单的比如整数变量 int a = 3;，那么直接用 a 就可以取到这个<strong>数值</strong>；</li><li>同样的道理，对于一个指针变量 int *a， <strong>它的值默认是内存中的某个地址</strong> ，那么直接用 <code>a</code> 就可以取到这个地址（当然得到地址没什么用就是了）；</li><li>稍微复杂一点的是数组变量 int a[3] = {1,2,3} ，单独的变量 a 并不会返回数组 {1,2,3}，而是数组首元素的地址（数组变量类似指针变量，虽然可以用 a[0] 来取出元素 1，但单独的它只是一个地址）</li></ul></li><li><p>变量的地址 <strong>（使用连字号 &amp; 访问）</strong></p><ul><li>简单的比如整数变量 int a = 3，用 &amp;a 可以取到该整数变量在内存中的<strong>地址</strong>；</li><li>对于数组变量 int a[3] = {1,2,3}，用 &amp;a[0] 可以取到第 0 个元素在内存中的<strong>地址</strong>（其实它和数组变量 a 的值是相同的）；</li><li>指针变量 int *a 也存在 &amp;a 的写法，意思是<strong>指针变量的指针</strong>，毕竟指针变量也是变量，也会在内存中有一个位置。</li></ul></li></ol><p>指针变量还有另外一个维度：</p><ol><li><p>地址所在的值 <strong>（使用星号 * 访问）</strong></p><ul><li><p>指针变量存在的一个重要意义就是，可以挪动它指向的地方，从而灵活的操作内存中的变量。</p></li><li><p>下面的例子展示了，指针变量 p 是如何改变指向的位置并且读取位置上的值：</p></li><li><pre class="highlight"><code class="c++"><span class="hljs-keyword">int</span> x[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 一个整数数组</span>
<span class="hljs-keyword">int</span> *p;  <span class="hljs-comment">// 一个指针变量</span>
p = &amp;x[<span class="hljs-number">1</span>]  <span class="hljs-comment">// 让 p 指向 x[1] 的地址</span>
<span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 结果是：2（x[1]的值）</span>
&lt;!--code￼<span class="hljs-number">0</span>--&gt;

</code></pre></li></ul></li></ol><h3 id="数组指针"><a class="markdownIt-Anchor" href="#数组指针"></a> 数组指针</h3><ol><li><p>在赋值的时候，一个数组变量=数组首位元素的地址（这里是隐式转换的结果，数组变量在赋值给指针的时候自动变成首位地址）</p></li><li><p>数组的方括号下标访问实际上只是指针取数的语法糖：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">a[<span class="number">3</span>];  <span class="comment">//  等价 *(a + 3);</span></span><br></pre></td></tr></table></figure></li><li><p>其实 <strong>方括号</strong> 和 <strong>星号</strong> 两种解指针的方法等价，而且都是源自指针的，指针也可以方括号访问地址解指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p[<span class="number">1</span>] &lt;&lt; *(p+<span class="number">1</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ol><h4 id="容易搞错的地方"><a class="markdownIt-Anchor" href="#容易搞错的地方"></a> 容易搞错的地方</h4><p>虽然数组变量本身很像一个指针变量（因为是第一个元素的地址），但是最好不要（大概也不能）当成指针变量来用。数组变量除了指针的特性，还带有数组长度的信息，这个是指针没有的。</p><p>可以逐个修改数组里面的元素，但是不能把其他地址的数组赋给已经有的数组变量了（数组变量不能拷贝）。</p><p>另外，指针变量必须指向已经存在于内存的变量地址（右边必须是变量），下面的情况数组还没建立，无法赋值给指针变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;  <span class="comment">// 错误的写法</span></span><br></pre></td></tr></table></figure><p>但是！字符串的场合又是可以的！因为右边字符串会先分配到内存，然后再是首位地址赋值给指针（所以为了避免混淆还是不要直接用数组/字符串赋值指针了吧）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* c = <span class="string">&quot;nihao&quot;</span>  <span class="comment">// 错误的写法</span></span><br><span class="line"><span class="comment">// warning: ISO C++11 does not allow conversion from string literal to &#x27;char *&#x27;</span></span><br></pre></td></tr></table></figure><p>总的来说，数组和字符串的地址应当是固定的，也就是说变量诞生到销毁指向的地址都是不应当改变的。</p><p>我们知道，给指针变量赋值数组首地址有两种写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">a = b;  <span class="comment">// 方法1</span></span><br><span class="line">a = &amp;b[<span class="number">0</span>] <span class="comment">// 方法2</span></span><br></pre></td></tr></table></figure><p>数组不仅可以存放基本数据类型，还可以存放任何对象</p><h4 id="用new创建数组"><a class="markdownIt-Anchor" href="#用new创建数组"></a> 用new创建数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//初始化前五个，后五个为0</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span>(*a)[<span class="number">100</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>][<span class="number">100</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="多维数组"><a class="markdownIt-Anchor" href="#多维数组"></a> 多维数组</h4><p><strong>初始化：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">	&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">	&#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;,</span><br><span class="line">	&#123; <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;  <span class="comment">// 效果同上</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 全部初始化为0</span></span><br><span class="line"><span class="comment">// int(*)[4] ia的类型是这个</span></span><br></pre></td></tr></table></figure><p><strong>遍历：</strong></p><p>首先二维数组其实是一个 <strong>指针的数组</strong>，指针是指向一个数组。以下是概念辨析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p[<span class="number">4</span>];  <span class="comment">// 一个包含 4 个整型指针的数组</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">4</span>];  <span class="comment">// 一个指向含有 4 个整数的数组的指针变量</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 阅读方法是，把变量拎出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为语法要求方括号在变量右边，我们阅读的时候可以拖到变量左边。</span></span><br><span class="line"><span class="keyword">int</span>*[<span class="number">4</span>] p;  <span class="comment">// 只是种阅读方式，不可以这样写</span></span><br><span class="line"><span class="keyword">int</span>[<span class="number">4</span>] (*p);  <span class="comment">// p 是一个指针，指向一个 4 个整数的数组</span></span><br></pre></td></tr></table></figure><p>上面 <strong>指向一个 4 个整数的数组的指针</strong> ，就是二维数组里面，第一层的元素。用指针去遍历它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">4</span>] = ia; p &lt; ia + <span class="number">4</span>; p++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> *q = *p; q &lt; *p + <span class="number">3</span>; q++) &#123;</span><br><span class="line">        cout &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方便的办法是用 auto：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p: ia) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;q: p) &#123;</span><br><span class="line">        cout &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 第二个 for 里面 p 是 <strong>指向指针的指针</strong>，容易搞混，解指针还是指针！</p><p>当然用下标访问也是可以的。</p><p><strong>另外：</strong> 多维数组的方括号也是语法糖：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span>(*a)[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">3</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;  <span class="comment">// 数组变量 a 实质上是一个 指针的数组</span></span><br><span class="line">**a  <span class="comment">// 取出 1</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>];  <span class="comment">// 等价于 *(a[1] + 0) ，第二行第一个元素，即 4</span></span><br><span class="line"><span class="comment">// 再细一点，等价于 *(*(a + 1) + 0)</span></span><br></pre></td></tr></table></figure><p>但是！（呕）二维数组变量 a 的类型并不是 int** （指向整型指针的指针），会报错</p><blockquote><p>cannot initialize a variable of type ‘int **’ with an rvalue of type ‘int (*)[3]’</p></blockquote><p>另外一个例子：这是一个打印二维数组的函数，可以看到 x “既是指针又不是指针”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>(&amp;x)[<span class="number">10</span>][<span class="number">20</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; ++j) &#123;</span><br><span class="line">            cout &lt;&lt; x[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">10</span>][<span class="number">20</span>];</span><br><span class="line"><span class="built_in">printMatrix</span>(x);  <span class="comment">// ok</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*x)[<span class="number">20</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">20</span>]; </span><br><span class="line"><span class="built_in">printMatrix</span>(x);  <span class="comment">// 不可以，因为定义的是 x 的引用</span></span><br></pre></td></tr></table></figure><p>但是，有个另外的初始化数组的办法，这样就可以用 int** 的办法传参了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>** a = <span class="keyword">new</span> <span class="keyword">int</span>*[<span class="number">5</span>];  <span class="comment">// new 创建的是对象的指针，正好 int*[5] 表示指向 int[5] 的指针</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>] &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;  <span class="comment">// 不一定每一行都相同的长度了</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><p>但是，此时 for-range 语句就失效了，因为 int** 没有给出 begin 和 end，for-range 没办法确定终止点</p><p>总的来说原生数组很不好用。。。</p><h4 id="数组的传参"><a class="markdownIt-Anchor" href="#数组的传参"></a> 数组的传参</h4><p>数组不能拷贝，所以尽量传数组的引用or指针。但是，传入函数以后，数组变量会退化成 <strong>首元素指针</strong> ，不管形参写的是（1）int* p（2）int p[3] （3）int p[]，函数内部都是把数组变量当成指针看待。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_ptr</span><span class="params">(<span class="keyword">int</span> p[<span class="number">4</span>])</span> </span>&#123;&#125;  <span class="comment">// 传入的本质还是首指针，可以</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_ptr</span><span class="params">(<span class="keyword">int</span> p[])</span> </span>&#123;&#125;  <span class="comment">// 传入的本质还是首指针，可以</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_ptr</span><span class="params">(<span class="keyword">int</span>* p)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_ref</span><span class="params">(<span class="keyword">int</span> (&amp;p)[<span class="number">4</span>])</span> </span>&#123;&#125;  <span class="comment">// 传入以后，数组被转化成 int(&amp;)[4] 类型，不是原来的数组变量 int[4] 类型了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f_ptr</span>(p);  <span class="comment">// 指针，数组 p 被自动识别为指针</span></span><br><span class="line"><span class="built_in">f_ptr</span>(&amp;p[<span class="number">0</span>]);  <span class="comment">// 指针值</span></span><br><span class="line"><span class="built_in">f_ref</span>(p);  <span class="comment">// 引用，相当于传入变量 p</span></span><br></pre></td></tr></table></figure><p><strong>多维数组</strong></p><p>传参：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_ptr</span><span class="params">(<span class="keyword">int</span> (*p)[<span class="number">4</span>])</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>模板法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> rows, <span class="keyword">size_t</span> cols&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_template</span><span class="params">(<span class="keyword">int</span> (&amp;p)[rows][cols])</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"><span class="built_in">f_template</span>(p);  <span class="comment">// 4 和 5 直接变成 rows、cols</span></span><br></pre></td></tr></table></figure><h4 id="总结一些常见用法"><a class="markdownIt-Anchor" href="#总结一些常见用法"></a> 总结一些常见用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1, *p2;</span><br><span class="line"><span class="keyword">int</span> x[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">p1 = &amp;x[<span class="number">0</span>];  <span class="comment">// 指向一个位置</span></span><br><span class="line">p2 = &amp;x[<span class="number">7</span>];</span><br><span class="line">*p1 = *(p2<span class="number">-1</span>);  <span class="comment">// *p1==7，赋值操作，*号取出来的变量</span></span><br></pre></td></tr></table></figure><h3 id="类的指针"><a class="markdownIt-Anchor" href="#类的指针"></a> 类的指针</h3><p>类的指针比较规范（不会出现数组和字符串那种奇奇怪怪的情况）</p><p>在定义一个类的指针，首先需要一个实例化的类：</p><h4 id="用-new-为类分配内存"><a class="markdownIt-Anchor" href="#用-new-为类分配内存"></a> 用 new 为类分配内存</h4><p>new 创建的对象返回指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;* p = <span class="keyword">new</span> vector&lt;<span class="keyword">int</span>&gt;();</span><br></pre></td></tr></table></figure><p>使用箭头运算符访问成员变量：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-tag">-</span>&gt;<span class="selector-tag">size</span>();</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-tag">-</span>&gt;<span class="selector-tag">empty</span>();</span><br><span class="line">(*p)<span class="selector-class">.empty</span>();  <span class="comment">// 等价于解开后的点运算符</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> new 对应的操作是 delete，但是 delete 只是清空指向的内存，指针本身并没有置空 nullptr，</p><h4 id="字符串的数组c11已废弃"><a class="markdownIt-Anchor" href="#字符串的数组c11已废弃"></a> 字符串的数组（c++11已废弃）</h4><p>字符串本身就是一个数组，所以字符串的数组应当是：<strong>指针变量的数组</strong></p><p>更新：定义指针的时候不要直接用未分配内存的字符串，这种方法不要用</p><p><strong>注意：</strong> 字符串变量虽然也是数组，但是可以直接交给 cout ，打印出来整个字符串（而不是首元素地址）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *names[] = &#123;</span><br><span class="line">                   <span class="string">&quot;Zara Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Hina Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Nuha Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Sara Ali&quot;</span>,</span><br><span class="line">   			   &#125;;</span><br><span class="line">cout &lt;&lt; names[<span class="number">0</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="引用是什么"><a class="markdownIt-Anchor" href="#引用是什么"></a> 引用是什么</h3><p>一般的赋值，都是值拷贝（修改副本影响不到本体）。下面的例子展示了值拷贝，如果 <strong>a = a + 1</strong> 右边赋给的不是值，而是地址，那会有一个无限迭代（不然 a 永远是 上一个 a 再 + 1）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">a = a + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>引用也可以解决地址拷贝的问题（另一个方法是指针），引用变量就是 a 的替身</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br><span class="line">b = <span class="number">2</span>;  <span class="comment">// a 也跟着变成 2</span></span><br></pre></td></tr></table></figure><h4 id="传参的时候用引用"><a class="markdownIt-Anchor" href="#传参的时候用引用"></a> 传参的时候用引用</h4><p>函数传参进来，默认是值拷贝，从调用的地方把值复制一遍传给函数。函数内部对我们的变量做了任何改动都影响不到外面的本体了</p><p>如果我们需要在函数里面影响到传进来的参数本身（比如修改数组的成员），就要把形参改成引用。</p><p><strong>swap的例子：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改数组元素的例子：</strong></p><p>函数传入一个数组的引用，返回数组某个元素的引用。</p><p><strong>注意：</strong> 函数类型也是引用，引用的定义必须有等号初始化（不能空引用）。传参的时候也必须是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法，即使返回引用，也修改不到原来的nums</span></span><br><span class="line"><span class="comment">// int&amp; setValue(vector&lt;int&gt; nums, int i) &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">setValue</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>&amp; x = nums[i];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">setValue</span>(nums, <span class="number">0</span>) = <span class="number">8</span>;  <span class="comment">// 返回引用就可以修改这个元素啦</span></span><br></pre></td></tr></table></figure><p>方便的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt;&amp; <span class="title">mulValue</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p: nums) p *= i;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，引用就是为了解决传参和出参总是产生副本的问题。（ <strong>从值传递变成引用传递</strong> ）</p><p>当返回一个引用时，要注意被引用的对象不能超出作用域。所以不要返回局部对象的引用，但是，可以返回一个对静态变量的引用。</p><h3 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h3><p><strong>堆内存：</strong> new、malloc 申请出来的，需要手动释放。空间大</p><p><strong>栈内存：</strong> 没用到 new、malloc 的，不用手动释放，空间小。</p><p><strong>malloc：</strong> 分配指定大小字节的内存。返回 void* 空类型的指针。void* 可以强制转换为任何类型的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* p;</span><br><span class="line">p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line">p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">100</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));  <span class="comment">// 分配 100个整数</span></span><br></pre></td></tr></table></figure><p><strong>new：</strong> 创建一个对象的指针，并为它自动分配内存</p><p><strong>delete：</strong> 释放指针指向的区域，但是指针必须指向初始位置！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">++p  <span class="comment">// 不可以移动！不然delete会报错</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure><h4 id="指针和-const"><a class="markdownIt-Anchor" href="#指针和-const"></a> 指针和 const</h4><p><strong>常量引用：</strong> 只能是常量引用才能作为常量的引用。因为绑定的时候，const 对象都是拷贝一个临时对象，然后绑定（然后就消失了，引用它无意义）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x1 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; x2 = x1;  <span class="comment">// 可以</span></span><br><span class="line"><span class="keyword">int</span>&amp; x2 = x1;  <span class="comment">// 不可以！</span></span><br></pre></td></tr></table></figure><p><strong>指向常量的指针：</strong> 不能改变指向对象的值（不代表对象不能改变！只是这个指针没有权限修改）。又叫 <strong>顶层 const</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p = &amp;x;</span><br><span class="line">*p = <span class="number">300</span>;  <span class="comment">// 不可以！</span></span><br></pre></td></tr></table></figure><p><strong>const 指针：</strong> 指针本身也是对象，也可以是一个常量变量（注意区别 <strong>指向常量的指针</strong> ）。又叫 <strong>底层 const</strong></p><p>常量指针在创建的时候必须初始化，而且初始化完成以后，它指向的地方就不可以改变了（不过它指向的值可以变）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x[<span class="number">2</span>] &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = x;</span><br><span class="line">p = x + <span class="number">1</span>;  <span class="comment">// 不可以！</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 看 const 的位置，从右往左，const int* p 表示 p 指向的对象不可变，int* const p 表示变量 p 本身不可变</p><p>也可以有双重 const 的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = <span class="string">&quot;12345&quot;</span></span><br></pre></td></tr></table></figure><p><strong>野指针：</strong> free 或者 delete 以后虽然内存清空了，但是指针变量还拥有那块内存地址的权限，他们有可能对内存做出无法预测的操作。（避免这个的办法是重新赋值为 nullptr 置空）</p><p><strong>内存泄露：</strong> 和野指针相反，指针看管的 new 或者 malloc 出来的内存还在使用中，指针却提取被置空 nullptr 了，此时这块内存就无人看管了，长此以往可以用的内存越来越少。</p><h3 id="重载和模板"><a class="markdownIt-Anchor" href="#重载和模板"></a> 重载和模板</h3><p>函数模板匹配到的参数类型可能和已经定义好的函数产生冲突</p><p>模板挑选的优先级是：</p><ol><li>非模板函数</li></ol><h3 id="显示特例化"><a class="markdownIt-Anchor" href="#显示特例化"></a> 显示特例化</h3><p>如果存在类型不能运行模板里面的运算or操作，需要单独处理这种类型。特例化的参数类型必须和之前声明的模板的类型匹配，如果特例化能匹配，就优先使用特例化的版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数模板不能满足字符串的比较</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> T &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a == b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;a, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 这里参数是指针的引用</p><p>类的特例化可以和模板类没有任何关系，除了名字相同</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/posts/1527658047/" rel="prev" title="Rmarkdown里面的表格"><i class="fa fa-chevron-left"></i> Rmarkdown里面的表格</a></div><div class="post-nav-item"><a href="/posts/415903961/" rel="next" title="C++的vector">C++的vector <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备2022005339号 </a><img src="/images/beian.png" alt=""><a href="http://beian.gov.cn/portal/registerSystemInfo?recordcode=11010802038986" rel="noopener" target="_blank">京公网安备 11010802038986号</a></div><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="author" itemprop="copyrightHolder">陈涵</span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" integrity="sha256-9/mhQQwkpU5okPfM5l0v3LnP9xtc6JK8dKW0/WlGaUc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/copy-tex.min.css" integrity="sha256-+oItviPaTmqjDhk4y4fLLUIMgRQYDV/ZyrRNvQiebWM=" crossorigin="anonymous"><script class="next-config" data-name="katex" type="application/json">{"copy_tex_js":{"url":"https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/copy-tex.min.js","integrity":"sha256-etSqbSVF4+Lwe8MGk/Vanc1sR+mWv+qOG73fxWw9p94="}}</script><script src="/js/third-party/math/katex.js"></script><script class="next-config" data-name="valine" type="application/json">{"enable":true,"appId":"UoQeuqgdeldMdxmboc6kUTKW-gzGzoHsz","appKey":"m1YPDJalPP8O4keGQyTXXAM5","serverURLs":"https://uoqeuqgd.lc-cn-n1-shared.com","placeholder":"欢迎评论","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":false,"enableQQ":false,"requiredFields":[],"notify":"45_cph@163.com","el":"#valine-comments","path":"/posts/3219915228/"}</script><script>document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.valine.el)
    .then(() => NexT.utils.getScript(
      'https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js',
      { condition: window.Valine }
    ))
    .then(() => {
      new Valine(CONFIG.valine);
    });
});</script></body></html>