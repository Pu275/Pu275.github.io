<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0"><link rel="preconnect" href="https//fonts.lug.ustc.edu.cn" crossorigin><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/head.jpg"><link rel="icon" type="image/png" sizes="32x32" href="/images/head.jpg"><link rel="icon" type="image/png" sizes="16x16" href="/images/head.jpg"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="baidu-site-verification" content="code-iieqrRhDAh"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"puhan.top","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":25,"offset":20},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":true,"nav":null,"activeClass":"valine"},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="指针是什么  指针是值为内存位置的变量。 每一个内存位置可使用连字号（&amp;）运算符访问。  ps： 现代的 C++ 程序应当尽量使用 vector 和迭代器，避免使用内置数组和指针；应当尽量使用 string，避免使用基于数组的字符串。"><meta property="og:type" content="article"><meta property="og:title" content="C++的指针(和引用)"><meta property="og:url" content="https://puhan.top/posts/3219915228/index.html"><meta property="og:site_name" content="陈涵的博客"><meta property="og:description" content="指针是什么  指针是值为内存位置的变量。 每一个内存位置可使用连字号（&amp;）运算符访问。  ps： 现代的 C++ 程序应当尽量使用 vector 和迭代器，避免使用内置数组和指针；应当尽量使用 string，避免使用基于数组的字符串。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-02-27T15:48:43.000Z"><meta property="article:modified_time" content="2022-03-11T14:17:00.561Z"><meta property="article:author" content="陈涵"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://puhan.top/posts/3219915228/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://puhan.top/posts/3219915228/","path":"posts/3219915228/","title":"C++的指针(和引用)"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++的指针(和引用) | 陈涵的博客</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">陈涵的博客</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-分类"><a href="/cate/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">指针是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="nav-text">数组指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E6%98%93%E6%90%9E%E9%94%99%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="nav-text">容易搞错的地方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-text">多维数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95"><span class="nav-text">总结一些常见用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-text">类的指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8-new-%E4%B8%BA%E7%B1%BB%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-text">用 new 为类分配内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%BB%84c11%E5%B7%B2%E5%BA%9F%E5%BC%83"><span class="nav-text">字符串的数组（c++11已废弃）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">引用是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E5%8F%82%E7%9A%84%E6%97%B6%E5%80%99%E7%94%A8%E5%BC%95%E7%94%A8"><span class="nav-text">传参的时候用引用</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="陈涵" src="/images/head.jpg"><p class="site-author-name" itemprop="name">陈涵</p><div class="site-description" itemprop="description">没有关系</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">28</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div><div class="cc-license site-overview-item animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://puhan.top/posts/3219915228/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><a href="/"><img class="site-author-image" itemprop="image" src="/%5Bobject%20Object%5D" alt=""></a><meta itemprop="image" content="/images/head.jpg"><meta itemprop="name" content="陈涵"><meta itemprop="description" content="没有关系"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="陈涵的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">C++的指针(和引用)</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-02-27 23:48:43" itemprop="dateCreated datePublished" datetime="2022-02-27T23:48:43+08:00">2022-02-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-03-11 22:17:00" itemprop="dateModified" datetime="2022-03-11T22:17:00+08:00">2022-03-11</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/posts/3219915228/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/posts/3219915228/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="指针是什么"><a class="markdownIt-Anchor" href="#指针是什么"></a> 指针是什么</h3><ol><li><strong>指针</strong>是值为内存位置的变量。</li><li>每一个内存位置可使用连字号（&amp;）运算符访问。</li></ol><p><strong>ps：</strong> 现代的 C++ 程序应当尽量使用 vector 和迭代器，避免使用内置数组和指针；应当尽量使用 string，避免使用基于数组的字符串。</p><span id="more"></span><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><p>变量的两个维度：</p><ol><li><p>变量的值 <strong>（使用变量本身访问）</strong></p><ul><li>简单的比如整数变量 <code>int a = 3;</code>，那么直接用 <code>a</code> 就可以取到这个<strong>数值</strong>；</li><li>同样的道理，对于一个指针变量 <code>int *a</code>，<strong>它的值默认是内存中的某个地址</strong>，那么直接用 <code>a</code> 就可以取到这个地址（当然得到地址没什么用就是了）；</li><li>稍微复杂一点的是数组变量 <code>int a[3] = &#123;1,2,3&#125;</code>，单独的变量 <code>a</code> 并不会返回数组 <code>&#123;1,2,3&#125;</code>，而是数组首元素的地址（数组变量类似指针变量，虽然可以用 <code>a[0]</code> 来取出元素 <code>1</code>，但单独的它只是一个地址）</li></ul></li><li><p>变量的地址 <strong>（使用连字号 &amp; 访问）</strong></p><ul><li>简单的比如整数变量 <code>int a = 3;</code>，用 <code>&amp;a</code> 可以取到该整数变量在内存中的<strong>地址</strong>；</li><li>对于数组变量 <code>int a[3] = &#123;1,2,3&#125;</code>，用 <code>&amp;a[0]</code> 可以取到第 0 个元素在内存中的<strong>地址</strong>（其实它和数组变量 <code>a</code> 的值是相同的）；</li><li>指针变量 <code>int *a</code> 也存在 <code>&amp;a</code> 的写法，意思是<strong>指针变量的指针</strong>，毕竟指针变量也是变量，也会在内存中有一个位置。</li></ul></li></ol><p>指针变量还有另外一个维度：</p><ol><li><p>地址所在的值 <strong>（使用星号 * 访问）</strong></p><ul><li><p>指针变量存在的一个重要意义就是，可以挪动它指向的地方，从而灵活的操作内存中的变量。</p></li><li><p>下面的例子展示了，指针变量 p 是如何改变指向的位置并且读取位置上的值：</p></li><li><pre class="highlight"><code class="c++"><span class="hljs-keyword">int</span> x[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 一个整数数组</span>
<span class="hljs-keyword">int</span> *p;  <span class="hljs-comment">// 一个指针变量</span>
p = &amp;x[<span class="hljs-number">1</span>]  <span class="hljs-comment">// 让 p 指向 x[1] 的地址</span>
<span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 结果是：2（x[1]的值）</span>
&lt;!--code￼<span class="hljs-number">0</span>--&gt;

</code></pre></li></ul></li></ol><h3 id="数组指针"><a class="markdownIt-Anchor" href="#数组指针"></a> 数组指针</h3><ol><li>在赋值的时候，一个数组变量=数组首位元素的地址（这里是隐式转换的结果，数组变量在赋值给指针的时候自动变成首位地址）</li></ol><h4 id="容易搞错的地方"><a class="markdownIt-Anchor" href="#容易搞错的地方"></a> 容易搞错的地方</h4><p>虽然数组变量本身很像一个指针变量（因为是第一个元素的地址），但是最好不要（大概也不能）当成指针变量来用</p><p>可以逐个修改数组里面的元素，但是不能把其他地址的数组赋给已经有的数组变量了。</p><p>另外，指针变量必须指向已经存在于内存的变量地址（右边必须是变量），下面的情况数组还没建立，无法赋值给指针变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;  <span class="comment">// 错误的写法</span></span><br></pre></td></tr></table></figure><p>但是！字符串的场合又是可以的！因为右边字符串会先分配到内存，然后再是首位地址赋值给指针（所以为了避免混淆还是不要直接用数组/字符串赋值指针了吧）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *c = <span class="string">&quot;nihao&quot;</span>  <span class="comment">// 错误的写法</span></span><br><span class="line"><span class="comment">// warning: ISO C++11 does not allow conversion from string literal to &#x27;char *&#x27;</span></span><br></pre></td></tr></table></figure><p>总的来说，数组和字符串的地址应当是固定的，也就是说变量诞生到销毁指向的地址都是不应当改变的。</p><p>我们知道，给指针变量赋值数组首地址有两种写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">a = b;  <span class="comment">// 方法1</span></span><br><span class="line">a = &amp;b[<span class="number">0</span>] <span class="comment">// 方法2</span></span><br></pre></td></tr></table></figure><h4 id="多维数组"><a class="markdownIt-Anchor" href="#多维数组"></a> 多维数组</h4><p><strong>初始化：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">	&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">	&#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;,</span><br><span class="line">	&#123; <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;  <span class="comment">// 效果同上</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 全部初始化为0</span></span><br></pre></td></tr></table></figure><p><strong>遍历：</strong></p><p>首先二维数组其实是一个 <strong>指针的数组</strong>，指针是指向一个数组。以下是概念辨析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p[<span class="number">4</span>];  <span class="comment">// 一个包含 4 个整型指针的数组</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">4</span>];  <span class="comment">// 一个指向含有 4 个整数的数组的指针变量</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 阅读方法是，把变量拎出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为语法要求方括号在变量右边，我们阅读的时候可以拖到变量左边。</span></span><br><span class="line"><span class="keyword">int</span>*[<span class="number">4</span>] p;  <span class="comment">// 只是种阅读方式，不可以这样写</span></span><br><span class="line"><span class="keyword">int</span>[<span class="number">4</span>] (*p);  <span class="comment">// p 是一个指针，指向一个 4 个整数的数组</span></span><br></pre></td></tr></table></figure><p>上面 <strong>指向一个 4 个整数的数组的指针</strong> ，就是二维数组里面，第一层的元素。用指针去遍历它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">4</span>] = ia; p &lt; ia + <span class="number">4</span>; p++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> *q = *p; q &lt; *p + <span class="number">3</span>; q++) &#123;</span><br><span class="line">        cout &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 第二个 for 里面 p 是 <strong>指向指针的指针</strong>，容易搞混，解指针还是指针！</p><p>方便的办法是用 auto：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p: ia) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;q: p) &#123;</span><br><span class="line">        cout &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然用下标访问也是可以的。</p><h4 id="总结一些常见用法"><a class="markdownIt-Anchor" href="#总结一些常见用法"></a> 总结一些常见用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1, *p2;</span><br><span class="line"><span class="keyword">int</span> x[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">p1 = &amp;x[<span class="number">0</span>];  <span class="comment">// 指向一个位置</span></span><br><span class="line">p2 = &amp;x[<span class="number">7</span>];</span><br><span class="line">*p1 = *(p2<span class="number">-1</span>);  <span class="comment">// *p1==7，赋值操作，*号取出来的变量</span></span><br></pre></td></tr></table></figure><h3 id="类的指针"><a class="markdownIt-Anchor" href="#类的指针"></a> 类的指针</h3><p>类的指针比较规范（不会出现数组和字符串那种奇奇怪怪的情况）</p><p>在定义一个类的指针，首先需要一个实例化的类：</p><h4 id="用-new-为类分配内存"><a class="markdownIt-Anchor" href="#用-new-为类分配内存"></a> 用 new 为类分配内存</h4><p>new 创建的对象返回指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;* p = <span class="keyword">new</span> vector&lt;<span class="keyword">int</span>&gt;();</span><br></pre></td></tr></table></figure><p>使用箭头运算符访问成员变量：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-tag">-</span>&gt;<span class="selector-tag">size</span>();</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-tag">-</span>&gt;<span class="selector-tag">empty</span>();</span><br><span class="line">(*p)<span class="selector-class">.empty</span>();  <span class="comment">// 等价于解开后的点运算符</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> new 对应的操作是 delete，但是 delete 只是清空指向的内存，指针本身并没有置空 nullptr，</p><h4 id="字符串的数组c11已废弃"><a class="markdownIt-Anchor" href="#字符串的数组c11已废弃"></a> 字符串的数组（c++11已废弃）</h4><p>字符串本身就是一个数组，所以字符串的数组应当是：<strong>指针变量的数组</strong></p><p>更新：定义指针的时候不要直接用未分配内存的字符串，这种方法不要用</p><p><strong>注意：</strong> 字符串变量虽然也是数组，但是可以直接交给 cout ，打印出来整个字符串（而不是首元素地址）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *names[] = &#123;</span><br><span class="line">                   <span class="string">&quot;Zara Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Hina Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Nuha Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Sara Ali&quot;</span>,</span><br><span class="line">   			   &#125;;</span><br><span class="line">cout &lt;&lt; names[<span class="number">0</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="引用是什么"><a class="markdownIt-Anchor" href="#引用是什么"></a> 引用是什么</h3><p>一般的赋值，都是值拷贝（修改副本影响不到本体）。下面的例子展示了值拷贝，如果 <strong>a = a + 1</strong> 右边赋给的不是值，而是地址，那会有一个无限迭代（不然 a 永远是 上一个 a 再 + 1）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">a = a + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>引用也可以解决地址拷贝的问题（另一个方法是指针），引用变量就是 a 的替身</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br><span class="line">b = <span class="number">2</span>;  <span class="comment">// a 也跟着变成 2</span></span><br></pre></td></tr></table></figure><h4 id="传参的时候用引用"><a class="markdownIt-Anchor" href="#传参的时候用引用"></a> 传参的时候用引用</h4><p>函数传参进来，默认是值拷贝，从调用的地方把值复制一遍传给函数。函数内部对我们的变量做了任何改动都影响不到外面的本体了</p><p>如果我们需要在函数里面影响到传进来的参数本身（比如修改数组的成员），就要把形参改成引用。</p><p><strong>swap的例子：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改数组元素的例子：</strong></p><p>函数传入一个数组的引用，返回数组某个元素的引用。</p><p><strong>注意：</strong> 函数类型也是引用，引用的定义必须有等号初始化（不能空引用）。传参的时候也必须是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法，即使返回引用，也修改不到原来的nums</span></span><br><span class="line"><span class="comment">// int&amp; setValue(vector&lt;int&gt; nums, int i) &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">setValue</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>&amp; x = nums[i];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">setValue</span>(nums, <span class="number">0</span>) = <span class="number">8</span>;  <span class="comment">// 返回引用就可以修改这个元素啦</span></span><br></pre></td></tr></table></figure><p>方便的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt;&amp; <span class="title">mulValue</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p: nums) p *= i;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，引用就是为了解决传参和出参总是产生副本的问题。（ <strong>从值传递变成引用传递</strong> ）</p><p>当返回一个引用时，要注意被引用的对象不能超出作用域。所以不要返回局部对象的引用，但是，可以返回一个对静态变量的引用。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/posts/1527658047/" rel="prev" title="Rmarkdown里面的表格"><i class="fa fa-chevron-left"></i> Rmarkdown里面的表格</a></div><div class="post-nav-item"><a href="/posts/415903961/" rel="next" title="C++的vector">C++的vector <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备2022005339号 </a><img src="/images/beian.png" alt=""><a href="http://beian.gov.cn/portal/registerSystemInfo?recordcode=11010802038986" rel="noopener" target="_blank">京公网安备 11010802038986号</a></div><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="author" itemprop="copyrightHolder">陈涵</span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" integrity="sha256-9/mhQQwkpU5okPfM5l0v3LnP9xtc6JK8dKW0/WlGaUc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/copy-tex.min.css" integrity="sha256-+oItviPaTmqjDhk4y4fLLUIMgRQYDV/ZyrRNvQiebWM=" crossorigin="anonymous"><script class="next-config" data-name="katex" type="application/json">{"copy_tex_js":{"url":"https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/copy-tex.min.js","integrity":"sha256-etSqbSVF4+Lwe8MGk/Vanc1sR+mWv+qOG73fxWw9p94="}}</script><script src="/js/third-party/math/katex.js"></script><script class="next-config" data-name="valine" type="application/json">{"enable":true,"appId":"UoQeuqgdeldMdxmboc6kUTKW-gzGzoHsz","appKey":"m1YPDJalPP8O4keGQyTXXAM5","serverURLs":"https://uoqeuqgd.api.lncldglobal.com","placeholder":null,"avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-cn","visitor":false,"comment_count":true,"recordIP":false,"enableQQ":false,"requiredFields":[],"el":"#valine-comments","path":"/posts/3219915228/"}</script><script>document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.valine.el)
    .then(() => NexT.utils.getScript(
      'https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js',
      { condition: window.Valine }
    ))
    .then(() => {
      new Valine(CONFIG.valine);
    });
});</script></body></html>