<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0"><link rel="preconnect" href="fonts.lug.ustc.edu.cn" crossorigin><link rel="preconnect" href="https://unpkg.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/head.jpg"><link rel="icon" type="image/png" sizes="32x32" href="/images/head.jpg"><link rel="icon" type="image/png" sizes="16x16" href="/images/head.jpg"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="baidu-site-verification" content="code-iieqrRhDAh"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"puhan.top","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":25,"offset":20},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":true,"nav":null,"activeClass":"valine"},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false,"format":"striptags","limit":10000}}</script><script src="/js/config.js"></script><meta name="description" content="c++类的一些基本用法"><meta property="og:type" content="article"><meta property="og:title" content="C++的类"><meta property="og:url" content="https://puhan.top/posts/2545696309/index.html"><meta property="og:site_name" content="陈涵的博客"><meta property="og:description" content="c++类的一些基本用法"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-03-07T10:15:43.000Z"><meta property="article:modified_time" content="2022-05-29T09:15:33.187Z"><meta property="article:author" content="陈涵"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://puhan.top/posts/2545696309/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://puhan.top/posts/2545696309/","path":"posts/2545696309/","title":"C++的类"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++的类 | 陈涵的博客</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">陈涵的博客</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-分类"><a href="/cate/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98"><span class="nav-text">实例成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">成员函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-text">初始化列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">默认构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">拷贝构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%91%E7%94%9F%E7%9A%84%E6%83%85%E5%BD%A2"><span class="nav-text">拷贝构造函数发生的情形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">什么时候自定义拷贝构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8D%E5%8F%91%E7%94%9F%E7%9A%84%E6%83%85%E5%BD%A2"><span class="nav-text">拷贝构造函数不发生的情形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copy-elision-%E5%AF%BC%E8%87%B4%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%A2%AB%E8%B7%B3%E8%BF%87"><span class="nav-text">copy elision 导致拷贝构造函数被跳过</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E8%BF%94%E5%9B%9E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-text">不要返回右值引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">拷贝赋值运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%92%8C%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">和拷贝构造函数的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-text">调用赋值函数的时机</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#public-%E5%92%8C-private"><span class="nav-text">public 和 private</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this-%E6%8C%87%E9%92%88"><span class="nav-text">this 指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E5%8F%82%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-text">传参指向常量的引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">常量成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="nav-text">可变数据成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#delete-%E5%88%A0%E9%99%A4%E7%9A%84"><span class="nav-text">delete 删除的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83"><span class="nav-text">友元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-text">类的隐式转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E6%AD%A5%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-text">一步隐式转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E5%8D%95%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">多个单参数构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E7%B1%BB%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-text">避免类的隐式转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#explicit-%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">explicit 会影响拷贝初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E7%9A%84%E6%97%B6%E5%80%99%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-text">需要的时候显式转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#explicit-bool"><span class="nav-text">explicit bool</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">static 静态成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">纯虚函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#typedef-struct"><span class="nav-text">typedef struct</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="nav-text">结构体指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%90%91%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-text">指向类成员函数的指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E9%87%8C%E9%9D%A2%E7%9A%84-typedef"><span class="nav-text">类里面的 typedef</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="陈涵" src="/images/head.jpg"><p class="site-author-name" itemprop="name">陈涵</p><div class="site-description" itemprop="description">没有关系</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">50</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div></nav></div><div class="cc-license site-overview-item animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://unpkg.com/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://puhan.top/posts/2545696309/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><a href="/"><img class="site-author-image" itemprop="image" src="/%5Bobject%20Object%5D" alt=""></a><meta itemprop="image" content="/images/head.jpg"><meta itemprop="name" content="陈涵"><meta itemprop="description" content="没有关系"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="陈涵的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">C++的类</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-03-07 18:15:43" itemprop="dateCreated datePublished" datetime="2022-03-07T18:15:43+08:00">2022-03-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-05-29 17:15:33" itemprop="dateModified" datetime="2022-05-29T17:15:33+08:00">2022-05-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/posts/2545696309/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/posts/2545696309/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><p>c++类的一些基本用法</p><span id="more"></span><h3 id="实例成员"><a class="markdownIt-Anchor" href="#实例成员"></a> 实例成员</h3><p>把 A 当成结构体来用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line">&#125;;  <span class="comment">// 结尾有分号</span></span><br></pre></td></tr></table></figure><p>实例化一个类有两种办法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A* a1 = <span class="keyword">new</span> <span class="built_in">A</span>();  <span class="comment">// 用 new 创建指针</span></span><br><span class="line">    cout &lt;&lt; a1-&gt;x;</span><br><span class="line">    A a2 = <span class="built_in">A</span>();  <span class="comment">// 直接创建</span></span><br><span class="line">    cout &lt;&lt; a2.x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="成员函数"><a class="markdownIt-Anchor" href="#成员函数"></a> 成员函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::print</span><span class="params">()</span> </span>&#123;<span class="comment">/*定义*/</span>&#125;</span><br></pre></td></tr></table></figure><p>外面的定义也要加类型，在里面也可定义，在里面定义的是隐式 inline 的。也可以在外部定义为 inline</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;<span class="comment">/*定义*/</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h3><p>构造函数和类的名称一样，不需要声明类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">A</span>() &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A* a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">cout &lt;&lt; a-&gt;x;  <span class="comment">// 结果是 x+1 = 4</span></span><br></pre></td></tr></table></figure><p>也可以先在 public 里面声明，然后再在外面定义构造函数</p><p><strong>注意：</strong> 声明构造函数用分号结尾，定义用花括号结尾</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">A</span>();</span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="built_in">A</span>() &#123;</span><br><span class="line">    ++x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化列表"><a class="markdownIt-Anchor" href="#初始化列表"></a> 初始化列表</h4><p>构造函数还可以为其他成员变量初始化：类名（括号）冒号初始化成员 花括号，不需要分号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">int</span> i);</span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="keyword">int</span> i): <span class="built_in">x</span>(i) &#123;  <span class="comment">// 把输入的参数 i 同时用来初始化成员 x 了</span></span><br><span class="line">    ++x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的相当于：（把构造函数挪到类里也是一样的）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A::<span class="built_in">A</span>(<span class="keyword">int</span> i): &#123;</span><br><span class="line">    x = i;</span><br><span class="line">    ++x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="默认构造函数"><a class="markdownIt-Anchor" href="#默认构造函数"></a> 默认构造函数</h4><p>如果自定义了一个构造函数，会导致编译器不再提供默认的合成构造函数。如果还希望有一个默认构造函数，需要手动指明。</p><p>编译器版本的构造函数会根据类内初始值对所有成员进行初始化（不给类内初始值就不初始化了），尽量还是用初始化列表版本的构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    	<span class="built_in">A</span>(<span class="keyword">int</span> a): <span class="built_in">x</span>(a) &#123;&#125;  <span class="comment">// 自定义构造函数</span></span><br><span class="line">    	<span class="built_in">A</span>() = <span class="keyword">default</span>;  <span class="comment">// 默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line">A a;  <span class="comment">// 这样默认的构造函数又可以用了</span></span><br></pre></td></tr></table></figure><h3 id="拷贝构造函数"><a class="markdownIt-Anchor" href="#拷贝构造函数"></a> 拷贝构造函数</h3><p>和构造函数的区别就是，它需要传入一个 const 版本的实例化的自己的引用</p><p>定义了这个函数，就可以 <strong>类名(实例名)</strong> 初始化一个新的类。如果没有定义，编译器也会提供默认的拷贝构造函数，将要拷贝的对象的成员逐个拷贝到新对象里面（同时会触发各个成员自己的拷贝构造函数）。</p><p>函数需要类支持拷贝操作才能进行传参，不然只能设为引用形参（对于非引用型变量，形参是对实参的拷贝）</p><h4 id="拷贝构造函数发生的情形"><a class="markdownIt-Anchor" href="#拷贝构造函数发生的情形"></a> 拷贝构造函数发生的情形</h4><p>1、对象被值传递的传参进函数（引用传递就不会调用拷贝构造函数了）</p><p>2、对象被返回为值出函数（返回类型是引用不会调用拷贝）（会不会被优化成移动呢？）</p><p>3、花括号列表初始化类成员（？）</p><p>4、拷贝初始化的时候会调用拷贝构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">const</span> A&amp; a) &#123;  <span class="comment">// 这个传入 const 类名引用 参数名 的就是拷贝构造函数</span></span><br><span class="line">            x = a.x;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">A a;</span><br><span class="line">a.x = <span class="number">100</span>;</span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">cout &lt;&lt; b.x;</span><br><span class="line">vector&lt;A&gt; v1 = &#123;a, b&#125;;  <span class="comment">// a 和 b 都发生拷贝初始化，调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><p>为什么加 const：加不加差不多，但是可以防止意外的修改。（拷贝的过程只读即可）</p><p>为什么要加引用呢，如果直接传类本身进 <strong>拷贝构造函数</strong>，会触发函数传参规则的 <strong>值传递拷贝</strong>，导致再次调用 <strong>拷贝构造函数</strong>，形成无限递归了。（放心，编译器会帮我们检查这个）</p><h4 id="什么时候自定义拷贝构造函数"><a class="markdownIt-Anchor" href="#什么时候自定义拷贝构造函数"></a> 什么时候自定义拷贝构造函数</h4><p>需要深拷贝的情况。简单来说，有指针用深拷贝。</p><p><strong>深拷贝：</strong> 在堆内存中开辟新的空间拷贝原来的数据</p><p><strong>浅拷贝：</strong> 编译器默认的拷贝方式，只拷贝值</p><p>有指针用浅拷贝就会导致指针指着的内存被指两次，那么析构的时候就 delete 两次了（如果有 delete 的话）</p><h4 id="拷贝构造函数不发生的情形"><a class="markdownIt-Anchor" href="#拷贝构造函数不发生的情形"></a> 拷贝构造函数不发生的情形</h4><p>传参引用、指针都不会调用拷贝构造函数</p><h4 id="copy-elision-导致拷贝构造函数被跳过"><a class="markdownIt-Anchor" href="#copy-elision-导致拷贝构造函数被跳过"></a> copy elision 导致拷贝构造函数被跳过</h4><p>如果传参一个右值，有可能触发编译器的 copy elision，导致调用默认构造函数而不是拷贝构造函数</p><h4 id="不要返回右值引用"><a class="markdownIt-Anchor" href="#不要返回右值引用"></a> 不要返回右值引用</h4><p>返回右值引用会妨碍 copy elision</p><h3 id="拷贝赋值运算符"><a class="markdownIt-Anchor" href="#拷贝赋值运算符"></a> 拷贝赋值运算符</h3><p>原来的对象会不会调用析构函数？</p><p>比较奇怪的是数组成员的所有元素也会跟着拷贝，这个和指针不一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string x = <span class="string">&quot;1234&quot;</span>;  <span class="comment">// 自己写的</span></span><br><span class="line">string x = <span class="built_in">string</span>(<span class="string">&quot;1234&quot;</span>);  <span class="comment">// 实际上应该是这样，隐含了 char 到 string 的转化</span></span><br><span class="line"><span class="function">string <span class="title">x</span><span class="params">(<span class="string">&quot;1234&quot;</span>)</span></span>; <span class="comment">// 编译器认为 &quot;1234&quot; 以后没用了，所以优化为默认构造函数</span></span><br><span class="line"><span class="comment">// 省略了拷贝构造函数</span></span><br></pre></td></tr></table></figure><h4 id="和拷贝构造函数的区别"><a class="markdownIt-Anchor" href="#和拷贝构造函数的区别"></a> 和拷贝构造函数的区别</h4><p>拷贝构造函数在产生对象的时候调用，赋值运算符 = 的左右两侧对象都必须已经存在。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>;  <span class="comment">// 直接初始化，默认构造函数</span></span><br><span class="line">string s2 = s1;  <span class="comment">// 拷贝初始化，拷贝构造函数</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="string">&quot;456&quot;</span>)</span></span>;</span><br><span class="line">s1 = s3;  <span class="comment">// 拷贝赋值运算符</span></span><br></pre></td></tr></table></figure><h4 id="调用赋值函数的时机"><a class="markdownIt-Anchor" href="#调用赋值函数的时机"></a> 调用赋值函数的时机</h4><p>变量声明的时候定义（拷贝初始化）调用拷贝构造函数，已经声明的调用赋值运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string x = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">string y = <span class="string">&quot;cba&quot;</span>;</span><br><span class="line">string z = x;  <span class="comment">// 这里调用的是拷贝构造函数！</span></span><br><span class="line">z = y;  <span class="comment">// 这里才是拷贝赋值</span></span><br></pre></td></tr></table></figure><h3 id="析构函数"><a class="markdownIt-Anchor" href="#析构函数"></a> 析构函数</h3><p>和构造函数的区别就是，释放内存（销毁）的时候希望执行的操作，同样不需要返回值，加个波浪号就行。</p><p>类销毁时首先调用它的析构函数，析构函数执行完毕，类成员也会依次执行销毁（分别调用自己的析构函数，没有析构函数就不调用。。）编译器提供一个默认的 <strong>合成析构函数</strong> 。不管提不提供析构函数，成员都会依次正常销毁，不用担心。析构函数的目的是处理一些额外的销毁（主要是指针）</p><p>析构函数触发的五个条件：</p><ol><li>对象离开作用域</li><li>对象的成员跟着对象一起销毁</li><li>容器元素跟着容器一起销毁（这个和 2 有区别吗）</li><li>delete 销毁指针指向的对象</li><li>临时对象的表达式创建完成（？）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>() &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;A is born&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;;</span><br><span class="line">        ~<span class="built_in">A</span>() &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;A is over&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// A::~A() &#123;&#125; 的定义也可以</span></span><br><span class="line"></span><br><span class="line">A* a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line"><span class="keyword">delete</span> a;</span><br></pre></td></tr></table></figure><h3 id="public-和-private"><a class="markdownIt-Anchor" href="#public-和-private"></a> public 和 private</h3><p>public、private（还有protected）的目的主要是为了继承。如果不指定，默认 private。标识符作用的范围一直到下一个其他标识符或者类结尾（和缩进没关系）</p><p><strong>public：</strong> 类里面全部可以互通，大家都有读写权限。</p><p><strong>private：</strong> 只有类函数的 <strong>里面</strong> 可以拿到 private 变量与函数的操作（读写）权限，其他情况都是无权限的（省得用户乱改）</p><p>一个类的 private 只能被这个类的其他成员或者这个类的友元访问, 无论这个成员是同一个实例中或是来自于不同的实例。所以 <strong>拷贝构造函数</strong> 是可以访问 private 的。</p><h3 id="this-指针"><a class="markdownIt-Anchor" href="#this-指针"></a> this 指针</h3><p>作用类似于 python 的 self，C<ins>类成员函数都自带一个 this 指针用来代指。只不过 C</ins> 一般不需要特别指出 <strong>这个变量是我们类里面的</strong> （也就是一般不用加 this） ，public 里面的成员到处都是可以访问的。除非是类内部的名称出现冲突，比如函数传入了其他重名的方法，才需要特别指出 <strong>这个方法是我们类里面特有的</strong></p><p>成员函数隐式的带有类实例对象的 this 指针。调用一个成员函数，首先用发出调用请求的地址初始化 this，</p><h4 id="传参指向常量的引用"><a class="markdownIt-Anchor" href="#传参指向常量的引用"></a> 传参指向常量的引用</h4><p>因为 this 是普通指针，可是传参一个常量的引用会导致 this 无法获取地址（参见指针一章，为了避免不必要的修改常量，限制普通指针获取常量地址，只有指向常量的指针才可以获取）导致传参常量的引用在函数内无法调用成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> A&amp; a)</span> </span>&#123;</span><br><span class="line">    a.<span class="built_in">method</span>();  <span class="comment">// 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量成员函数"><a class="markdownIt-Anchor" href="#常量成员函数"></a> 常量成员函数</h3><p>后置 const 让隐式调用的this指针能够指向常量，加上 const</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;  <span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> name; &#125;  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>如果常量成员函数返回 *this 引用，那么会自动转换为 const *this&amp; 。</p><ul><li>常量类只能调用常量成员函数</li><li>常量成员函数如果返回 *this 的引用只能是常量引用，这样就没法传递给其他非常量成员函数了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Screen&amp; <span class="title">display1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Screen&amp; <span class="title">display2</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">Screen screen;  <span class="comment">// 非常量类</span></span><br><span class="line">screen.<span class="built_in">display1</span>().<span class="built_in">set</span>(<span class="string">&#x27;3&#x27;</span>);  <span class="comment">// 可以链式法则</span></span><br><span class="line"><span class="keyword">const</span> Screen screen;  <span class="comment">// 常量类</span></span><br><span class="line">screen.<span class="built_in">display2</span>();  <span class="comment">// 不能链式法则，而且成员函数也得定做</span></span><br></pre></td></tr></table></figure><p>这个故事告诉我们常量类没什么用还很麻烦。也不会为了常量类把成员函数全部重载一个 const 版本吧。。</p><h3 id="可变数据成员"><a class="markdownIt-Anchor" href="#可变数据成员"></a> 可变数据成员</h3><p>给一些成员变量特别的权限，使得他们在常量成员函数里面也能被修改。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        ++x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="delete-删除的"><a class="markdownIt-Anchor" href="#delete-删除的"></a> delete 删除的</h3><p>设置一些成员为“删除的”，显式阻止这个成员的操作，比如说禁止类赋值、类拷贝。感觉也没什么用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  	<span class="built_in">A</span>() = <span class="keyword">delete</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="友元"><a class="markdownIt-Anchor" href="#友元"></a> 友元</h3><p>有些函数不是类成员，但是和类关系紧密。如果我们把类的数据放进 private，那么这些友好函数就访问不到了。把这些函数声明成类的友元就可以解决这个问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> A&amp;)</span></span>;  <span class="comment">// 在开头声明即可</span></span><br><span class="line">  	<span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> A&amp; a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; A.x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的隐式转换"><a class="markdownIt-Anchor" href="#类的隐式转换"></a> 类的隐式转换</h3><p>如果自定义了一个 <strong>只有一个形参</strong> 的构造函数，同时也定义了类的隐式转换。隐式转换类似：输入实参，构造类，传入类。最经典的是 string 的例子</p><p>发生的场合：类的拷贝初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(string s)</span></span>;  <span class="comment">// string</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1234&quot;</span>);  <span class="comment">// char</span></span><br><span class="line">s = <span class="string">&quot;1234&quot;</span>;  <span class="comment">// 拷贝初始化也是一个隐式转换</span></span><br></pre></td></tr></table></figure><p>虽然函数要求 string 类型的参数，但是我们传入的是 char，因为 string 可以从 char 构造，所以发生了隐式转换。</p><h4 id="一步隐式转换"><a class="markdownIt-Anchor" href="#一步隐式转换"></a> 一步隐式转换</h4><p>编译器只能执行一次隐式转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="built_in">A</span>(string s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(A a)</span></span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>);  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>用类 A 再包裹一层 string，这样 char 要想变成 A 得经过两次转换，就不行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>;  <span class="comment">// 但是这样可以成功初始化</span></span><br></pre></td></tr></table></figure><p>这里是构造函数发生了 char 到 string 的隐式转换。</p><h4 id="多个单参数构造函数"><a class="markdownIt-Anchor" href="#多个单参数构造函数"></a> 多个单参数构造函数</h4><p>编译器会挑选满足条件的进行隐式转换</p><h3 id="避免类的隐式转换"><a class="markdownIt-Anchor" href="#避免类的隐式转换"></a> 避免类的隐式转换</h3><p>不需要构造函数的隐式转换，加上 explicit 即可。</p><p><strong>注意：</strong> explicit 只在类内部写，而且只对单参数构造函数有效</p><h4 id="explicit-会影响拷贝初始化"><a class="markdownIt-Anchor" href="#explicit-会影响拷贝初始化"></a> explicit 会影响拷贝初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="keyword">const</span> A&amp;)</span></span>;</span><br><span class="line">A a = <span class="built_in">A</span>(<span class="number">2</span>);  <span class="comment">// 错误，禁止隐式</span></span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(A(<span class="number">2</span>))</span></span>;  <span class="comment">// 正确，显式调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><p>拷贝初始化隐含了（1）创建临时对象 A(2) （2）调用 a 的拷贝构造函数。加入 explicit 应该就是禁用了这个隐式调用吧</p><h4 id="需要的时候显式转换"><a class="markdownIt-Anchor" href="#需要的时候显式转换"></a> 需要的时候显式转换</h4><p>使用 static_cast 处理 explicit 的额外情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">A a = <span class="keyword">static_cast</span>&lt;A&gt;(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="explicit-bool"><a class="markdownIt-Anchor" href="#explicit-bool"></a> explicit bool</h4><p>即使重载了类的 bool 转换，在 Contextual conversion 的情况下依然会被显式的调用。</p><p>contextual conversion：只针对 bool 类型发生的转换（结果上是显式的），if、for、while 等场合发生</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (x == <span class="number">1</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line">A a;</span><br><span class="line"><span class="keyword">if</span> (a) &#123;&#125;</span><br></pre></td></tr></table></figure><p>可以用于判断 A 的成员</p><h3 id="static-静态成员"><a class="markdownIt-Anchor" href="#static-静态成员"></a> static 静态成员</h3><p>静态成员不是构造函数初始化的，得从外部定义，而且只能定义一次，并且存在程序的整个生命周期中。</p><p>静态成员的任何改动都会影响到所有类实例。静态成员在内存有自己的专属区域</p><p>静态成员一般用来表示一个公有的、可以不断变动的值。比如利率、价格</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">static</span> <span class="keyword">int</span> rate;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">initRate</span><span class="params">()</span> </span>&#123; rate = <span class="number">10</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A::rate = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> A::rate = <span class="built_in">initRate</span>();  <span class="comment">// A 表示进入了类的作用域，因此 initRate 不需要 A::了</span></span><br></pre></td></tr></table></figure><p>对于 static 成员函数，由于 static 变量存在于类，而不是实例化的对象，static 成员函数没有 this 指针，也就不能访问类的成员变量</p><h3 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h3><p>父类调用子类的方法。</p><h4 id="虚函数"><a class="markdownIt-Anchor" href="#虚函数"></a> 虚函数</h4><p>定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。下面的例子可以看到，非虚函数是调用基类的，虚函数是调用子类覆盖定义的版本。</p><p>这样我们可以把很多派生类的行为用一个统一的基类的函数处理，即使它们有不同的实现。函数 test 包含一个派生类到基类的隐式转换（基类不可以隐式转换到派生类）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="built_in">Shape</span>(<span class="keyword">int</span> w, <span class="keyword">int</span> h): <span class="built_in">width</span>(w), <span class="built_in">height</span>(h) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;not virtual&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vtest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;is virtual&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="keyword">int</span> w, <span class="keyword">int</span> h): Shape &#123;w, h&#125; &#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;test is not overide&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vtest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;test is overide&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Shape&amp; shape)</span> </span>&#123;</span><br><span class="line">    shape.<span class="built_in">test</span>();</span><br><span class="line">    shape.<span class="built_in">vtest</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Rectangle <span class="title">rec</span><span class="params">(<span class="number">10</span>, <span class="number">7</span>)</span></span>;  <span class="comment">// Rectangle类重写了方法 area</span></span><br><span class="line"><span class="built_in">test</span>(rec);</span><br><span class="line"><span class="comment">// not virtual</span></span><br><span class="line"><span class="comment">// test is overide</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 成员函数和成员变量是分开存放的，因为类实例只需要共享一份函数，所以没必要为每个实例在内存分配函数的空间，而是共享一份存储在代码区的函数即可。带虚函数的对象在内存开头存储了一个虚函数表（里面是函数指针），被 Rectangle 继承走。调用和覆写虚函数都是通过访问自己拥有的虚函数表，这样就可以实现不同的派生类有自己的虚函数实现版本。</p><p>派生类可以隐式转化成基类，基类不能隐式转化成派生类。派生类到基类转化的工作由基类指针来完成</p><h4 id="纯虚函数"><a class="markdownIt-Anchor" href="#纯虚函数"></a> 纯虚函数</h4><p>有纯虚函数的类就是抽象类，不能被实例化。纯虚函数必须在子类里面重新定义（毕竟他本来没有含义）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funtion1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3><h4 id="typedef-struct"><a class="markdownIt-Anchor" href="#typedef-struct"></a> typedef struct</h4><p>这个是 C 语言的写法，有些时候会看到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span>&#125;;  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>&#125; A;  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">a</span>;</span>  <span class="comment">// C语言 1 得这样定义</span></span><br></pre></td></tr></table></figure><p>（1）是 C++ 常用的写法，没什么问题；（2）是 C 语言的写法，因为如果在 C 里面用（1）的话，使用结构体 A 必须带上 struct。为了简便，使用（2）的写法可以省略声明时候的 struct。C++ 里面 class、struct 都隐式的进行了 typedef 的操作，所以不用这么写。</p><h4 id="结构体指针"><a class="markdownIt-Anchor" href="#结构体指针"></a> 结构体指针</h4><p>结构体不能强制转换，但是结构体指针可以。下面这个例子，只要 Rectangle 把“继承”来的结构体 Shape 放在首位实例 shape，那么可以把 rec 的指针强制转换成 Shape 类型的指针（这是不是就是类似多态呢）如果 Rectangle 在 shape 前面放了其他数据，那么强制转换就会解析失败了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; Shape;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Shape shape;</span><br><span class="line">&#125; Rectangle;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(Shape* shape, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">    shape-&gt;x += dx;</span><br><span class="line">    shape-&gt;y += dy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rectangle rec;</span><br><span class="line">Shape* s = (Shape*) &amp;rec;</span><br><span class="line"><span class="built_in">move</span>(s, <span class="number">2</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h4 id="指向类成员函数的指针"><a class="markdownIt-Anchor" href="#指向类成员函数的指针"></a> 指向类成员函数的指针</h4><p>成员函数指针 p 的声明：指向类 A 成员函数 f 的，无参数的，无返回值的函数</p><p>成员函数指针 q 的声明：指向类 A 成员函数 g 的，int 参数的，返回 int 的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">A a1;</span><br><span class="line">A* a2 = &amp;a1;</span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (A::* p) (<span class="keyword">void</span>) = &amp;A::f;</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (A::* q) (<span class="keyword">int</span>) = &amp;A::g;</span><br><span class="line">(a1.*p)();  <span class="comment">// 1</span></span><br><span class="line">(a2-&gt;*p)();  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>成员函数指针依赖被一个实例对象调用，不能直接解引用。注意星号的位置是在类的后面</p><h4 id="类里面的-typedef"><a class="markdownIt-Anchor" href="#类里面的-typedef"></a> 类里面的 typedef</h4><p>一个例子是 vector 的 iterator：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (std::vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于在 vector 类的 namespace 下面定义了新的变量类型 iterator</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line">  	<span class="keyword">typedef</span> <span class="keyword">int</span>* iterator;  <span class="comment">// 类似这个实现  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/posts/1726193520/" rel="prev" title="接雨水"><i class="fa fa-chevron-left"></i> 接雨水</a></div><div class="post-nav-item"><a href="/posts/2810482356/" rel="next" title="简单的排序">简单的排序 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备2022005339号 </a><img src="/images/beian.png" alt=""><a href="http://beian.gov.cn/portal/registerSystemInfo?recordcode=11010802038986" rel="noopener" target="_blank">京公网安备 11010802038986号</a></div><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="author" itemprop="copyrightHolder">陈涵</span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="https://unpkg.com/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://unpkg.com/katex@0.15.1/dist/katex.min.css" integrity="sha256-9/mhQQwkpU5okPfM5l0v3LnP9xtc6JK8dKW0/WlGaUc=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/katex@0.15.1/dist/contrib/copy-tex.min.css" integrity="sha256-+oItviPaTmqjDhk4y4fLLUIMgRQYDV/ZyrRNvQiebWM=" crossorigin="anonymous"><script class="next-config" data-name="katex" type="application/json">{"copy_tex_js":{"url":"https://unpkg.com/katex@0.15.1/dist/contrib/copy-tex.min.js","integrity":"sha256-etSqbSVF4+Lwe8MGk/Vanc1sR+mWv+qOG73fxWw9p94="}}</script><script src="/js/third-party/math/katex.js"></script><script class="next-config" data-name="valine" type="application/json">{"enable":true,"appId":"UoQeuqgdeldMdxmboc6kUTKW-gzGzoHsz","appKey":"m1YPDJalPP8O4keGQyTXXAM5","serverURLs":"https://uoqeuqgd.lc-cn-n1-shared.com","placeholder":"欢迎评论","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":false,"enableQQ":false,"requiredFields":[],"notify":"45_cph@163.com","el":"#valine-comments","path":"/posts/2545696309/"}</script><script>document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.valine.el)
    .then(() => NexT.utils.getScript(
      'https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js',
      { condition: window.Valine }
    ))
    .then(() => {
      new Valine(CONFIG.valine);
    });
});</script></body></html>