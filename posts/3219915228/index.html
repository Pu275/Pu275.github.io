<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0"><link rel="preconnect" href="https://fonts.lug.ustc.edu.cn" crossorigin><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/head.jpg"><link rel="icon" type="image/png" sizes="32x32" href="/images/head.jpg"><link rel="icon" type="image/png" sizes="16x16" href="/images/head.jpg"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="baidu-site-verification" content="code-iieqrRhDAh"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"puhan.top","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":25,"offset":20},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":true,"nav":null,"activeClass":"valine"},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false,"format":"striptags","limit":10000}}</script><script src="/js/config.js"></script><meta name="description" content="指针是什么  指针是值为内存位置的变量。 每一个内存位置可使用连字号（&amp;）运算符访问。  ps： 现代的 C++ 程序应当尽量使用 vector 和迭代器，避免使用内置数组和指针；应当尽量使用 string，避免使用基于数组的字符串。"><meta property="og:type" content="article"><meta property="og:title" content="C++的指针(和引用)"><meta property="og:url" content="https://puhan.top/posts/3219915228/index.html"><meta property="og:site_name" content="陈涵的博客"><meta property="og:description" content="指针是什么  指针是值为内存位置的变量。 每一个内存位置可使用连字号（&amp;）运算符访问。  ps： 现代的 C++ 程序应当尽量使用 vector 和迭代器，避免使用内置数组和指针；应当尽量使用 string，避免使用基于数组的字符串。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-02-27T15:48:43.000Z"><meta property="article:modified_time" content="2022-06-04T13:28:17.825Z"><meta property="article:author" content="陈涵"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://puhan.top/posts/3219915228/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://puhan.top/posts/3219915228/","path":"posts/3219915228/","title":"C++的指针(和引用)"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++的指针(和引用) | 陈涵的博客</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">陈涵的博客</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-分类"><a href="/cate/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">指针是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="nav-text">数组指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E6%98%93%E6%90%9E%E9%94%99%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="nav-text">容易搞错的地方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8new%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="nav-text">用new创建数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-text">多维数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%A0%E5%8F%82"><span class="nav-text">数组的传参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95"><span class="nav-text">总结一些常见用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-text">类的指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8-new-%E4%B8%BA%E7%B1%BB%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-text">用 new 为类分配内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8C%E9%9D%A2-new-%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-text">函数里面 new 的指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E9%87%8C%E9%9D%A2-new-%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-text">类里面 new 的指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%BB%84c11%E5%B7%B2%E5%BA%9F%E5%BC%83"><span class="nav-text">字符串的数组（c++11已废弃）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">引用是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E5%8F%82%E7%9A%84%E6%97%B6%E5%80%99%E7%94%A8%E5%BC%95%E7%94%A8"><span class="nav-text">传参的时候用引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E6%95%B0%E7%BB%84%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-text">原生数组的引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98"><span class="nav-text">内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E5%86%85%E5%AD%98"><span class="nav-text">拷贝内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C-const"><span class="nav-text">指针和 const</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shared_ptr"><span class="nav-text">shared_ptr</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reset-%E5%92%8C%E8%B5%8B%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">reset 和赋值的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E7%90%86-new-%E5%87%BA%E6%9D%A5%E7%9A%84%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="nav-text">管理 new 出来的数组（动态数组）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">错误的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E7%9A%84%E4%BC%A0%E5%8F%82"><span class="nav-text">错误的传参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E9%87%8C%E9%9D%A2%E7%9A%84%E5%85%B1%E4%BA%AB%E6%8C%87%E9%92%88"><span class="nav-text">类里面的共享指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const-%E7%9A%84%E5%85%B1%E4%BA%AB%E6%8C%87%E9%92%88"><span class="nav-text">const 的共享指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-text">一个链表的例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unique_ptr"><span class="nav-text">unique_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-text">函数指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8"><span class="nav-text">调用</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="陈涵" src="/images/head.jpg"><p class="site-author-name" itemprop="name">陈涵</p><div class="site-description" itemprop="description">没有关系</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">50</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div></nav></div><div class="cc-license site-overview-item animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://puhan.top/posts/3219915228/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><a href="/"><img class="site-author-image" itemprop="image" src="/%5Bobject%20Object%5D" alt=""></a><meta itemprop="image" content="/images/head.jpg"><meta itemprop="name" content="陈涵"><meta itemprop="description" content="没有关系"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="陈涵的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">C++的指针(和引用)</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-02-27 23:48:43" itemprop="dateCreated datePublished" datetime="2022-02-27T23:48:43+08:00">2022-02-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-06-04 21:28:17" itemprop="dateModified" datetime="2022-06-04T21:28:17+08:00">2022-06-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/posts/3219915228/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/posts/3219915228/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="指针是什么"><a class="markdownIt-Anchor" href="#指针是什么"></a> 指针是什么</h3><ol><li><strong>指针</strong>是值为内存位置的变量。</li><li>每一个内存位置可使用连字号（&amp;）运算符访问。</li></ol><p><strong>ps：</strong> 现代的 C++ 程序应当尽量使用 vector 和迭代器，避免使用内置数组和指针；应当尽量使用 string，避免使用基于数组的字符串。</p><span id="more"></span><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><p>变量的两个维度：</p><ol><li><p>变量的值 <strong>（使用变量本身访问）</strong></p><ul><li>简单的比如整数变量 int a = 3;，那么直接用 a 就可以取到这个<strong>数值</strong>；</li><li>同样的道理，对于一个指针变量 int *a， <strong>它的值默认是内存中的某个地址</strong> ，那么直接用 <code>a</code> 就可以取到这个地址（当然得到地址没什么用就是了）；</li><li>稍微复杂一点的是数组变量 int a[3] = {1,2,3} ，单独的变量 a 并不会返回数组 {1,2,3}，而是数组首元素的地址（数组变量类似指针变量，虽然可以用 a[0] 来取出元素 1，但单独的它只是一个地址）</li></ul></li><li><p>变量的地址 <strong>（使用连字号 &amp; 访问）</strong></p><ul><li>简单的比如整数变量 int a = 3，用 &amp;a 可以取到该整数变量在内存中的<strong>地址</strong>；</li><li>对于数组变量 int a[3] = {1,2,3}，用 &amp;a[0] 可以取到第 0 个元素在内存中的<strong>地址</strong>（其实它和数组变量 a 的值是相同的）；</li><li>指针变量 int *a 也存在 &amp;a 的写法，意思是<strong>指针变量的指针</strong>，毕竟指针变量也是变量，也会在内存中有一个位置。</li></ul></li></ol><p>指针变量还有另外一个维度：</p><ol><li><p>地址所在的值 <strong>（使用星号 * 访问）</strong></p><ul><li><p>指针变量存在的一个重要意义就是，可以挪动它指向的地方，从而灵活的操作内存中的变量。</p></li><li><p>下面的例子展示了，指针变量 p 是如何改变指向的位置并且读取位置上的值：</p></li><li><pre class="highlight"><code class="c++"><span class="hljs-keyword">int</span> x[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 一个整数数组</span>
<span class="hljs-keyword">int</span> *p;  <span class="hljs-comment">// 一个指针变量</span>
p = &amp;x[<span class="hljs-number">1</span>]  <span class="hljs-comment">// 让 p 指向 x[1] 的地址</span>
<span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 结果是：2（x[1]的值）</span>
&lt;!--code￼<span class="hljs-number">0</span>--&gt;

</code></pre></li></ul></li></ol><h3 id="数组指针"><a class="markdownIt-Anchor" href="#数组指针"></a> 数组指针</h3><ol><li><p>在赋值的时候，一个数组变量=数组首位元素的地址（这里是隐式转换的结果，数组变量在赋值给指针的时候自动变成首位地址）</p></li><li><p>数组的方括号下标访问实际上只是指针取数的语法糖：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">a[<span class="number">3</span>];  <span class="comment">//  等价 *(a + 3);</span></span><br></pre></td></tr></table></figure></li><li><p>其实 <strong>方括号</strong> 和 <strong>星号</strong> 两种解指针的方法等价，而且都是源自指针的，指针也可以方括号访问地址解指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p[<span class="number">1</span>] &lt;&lt; *(p+<span class="number">1</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ol><h4 id="容易搞错的地方"><a class="markdownIt-Anchor" href="#容易搞错的地方"></a> 容易搞错的地方</h4><p>虽然数组变量本身很像一个指针变量（因为是第一个元素的地址），但是最好不要（大概也不能）当成指针变量来用。数组变量除了指针的特性，还带有数组长度的信息，这个是指针没有的。</p><p>可以逐个修改数组里面的元素，但是不能把其他地址的数组赋给已经有的数组变量了（数组变量不能拷贝）。</p><p>另外，指针变量必须指向已经存在于内存的变量地址（右边必须是变量），下面的情况数组还没建立，无法赋值给指针变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;  <span class="comment">// 错误的写法</span></span><br></pre></td></tr></table></figure><p>但是！字符串的场合又是可以的！因为右边字符串会先分配到内存，然后再是首位地址赋值给指针（所以为了避免混淆还是不要直接用数组/字符串赋值指针了吧）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* c = <span class="string">&quot;nihao&quot;</span>  <span class="comment">// 错误的写法</span></span><br><span class="line"><span class="comment">// warning: ISO C++11 does not allow conversion from string literal to &#x27;char *&#x27;</span></span><br></pre></td></tr></table></figure><p>总的来说，数组和字符串的地址应当是固定的，也就是说变量诞生到销毁指向的地址都是不应当改变的。</p><p>我们知道，给指针变量赋值数组首地址有两种写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">a = b;  <span class="comment">// 方法1</span></span><br><span class="line">a = &amp;b[<span class="number">0</span>] <span class="comment">// 方法2</span></span><br></pre></td></tr></table></figure><p>数组不仅可以存放基本数据类型，还可以存放任何对象</p><h4 id="用new创建数组"><a class="markdownIt-Anchor" href="#用new创建数组"></a> 用new创建数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//初始化前五个，后五个为0</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span>(*a)[<span class="number">100</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>][<span class="number">100</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="多维数组"><a class="markdownIt-Anchor" href="#多维数组"></a> 多维数组</h4><p><strong>初始化：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">	&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">	&#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;,</span><br><span class="line">	&#123; <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;  <span class="comment">// 效果同上</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 全部初始化为0</span></span><br><span class="line"><span class="comment">// int(*)[4] ia的类型是这个</span></span><br></pre></td></tr></table></figure><p><strong>遍历：</strong></p><p>首先二维数组其实是一个 <strong>指针的数组</strong>，指针是指向一个数组。以下是概念辨析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p[<span class="number">4</span>];  <span class="comment">// 一个包含 4 个整型指针的数组</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">4</span>];  <span class="comment">// 一个指向含有 4 个整数的数组的指针变量</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 阅读方法是，把变量拎出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为语法要求方括号在变量右边，我们阅读的时候可以拖到变量左边。</span></span><br><span class="line"><span class="keyword">int</span>*[<span class="number">4</span>] p;  <span class="comment">// 只是种阅读方式，不可以这样写</span></span><br><span class="line"><span class="keyword">int</span>[<span class="number">4</span>] (*p);  <span class="comment">// p 是一个指针，指向一个 4 个整数的数组</span></span><br></pre></td></tr></table></figure><p>上面 <strong>指向一个 4 个整数的数组的指针</strong> ，就是二维数组里面，第一层的元素。用指针去遍历它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">4</span>] = ia; p &lt; ia + <span class="number">4</span>; p++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> *q = *p; q &lt; *p + <span class="number">3</span>; q++) &#123;</span><br><span class="line">        cout &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方便的办法是用 auto：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p: ia) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;q: p) &#123;</span><br><span class="line">        cout &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 第二个 for 里面 p 是 <strong>指向指针的指针</strong>，容易搞混，解指针还是指针！</p><p>当然用下标访问也是可以的。指针与指针还可以做减法，结果就是偏移量。</p><p><strong>另外：</strong> 多维数组的方括号也是语法糖：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span>(*a)[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">3</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;  <span class="comment">// 数组变量 a 实质上是一个 指针的数组</span></span><br><span class="line">**a  <span class="comment">// 取出 1</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>];  <span class="comment">// 等价于 *(a[1] + 0) ，第二行第一个元素，即 4</span></span><br><span class="line"><span class="comment">// 再细一点，等价于 *(*(a + 1) + 0)</span></span><br></pre></td></tr></table></figure><p>但是！（呕）二维数组变量 a 的类型并不是 int** （指向整型指针的指针），会报错</p><blockquote><p>cannot initialize a variable of type ‘int **’ with an rvalue of type ‘int (*)[3]’</p></blockquote><p>另外一个例子：这是一个打印二维数组的函数，可以看到 x “既是指针又不是指针”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>(&amp;x)[<span class="number">10</span>][<span class="number">20</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; ++j) &#123;</span><br><span class="line">            cout &lt;&lt; x[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">10</span>][<span class="number">20</span>];</span><br><span class="line"><span class="built_in">printMatrix</span>(x);  <span class="comment">// ok</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*x)[<span class="number">20</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">20</span>]; </span><br><span class="line"><span class="built_in">printMatrix</span>(x);  <span class="comment">// 不可以，因为定义的是 x 的引用</span></span><br></pre></td></tr></table></figure><p>但是，有个另外的初始化数组的办法，这样就可以用 int** 的办法传参了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>** a = <span class="keyword">new</span> <span class="keyword">int</span>*[<span class="number">5</span>];  <span class="comment">// new 创建的是对象的指针，正好 int*[5] 表示指向 int[5] 的指针</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>] &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;  <span class="comment">// 不一定每一行都相同的长度了</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><p>但是，此时 for-range 语句就失效了，因为 int** 没有给出 begin 和 end，for-range 没办法确定终止点</p><p>总的来说原生数组很不好用。。。</p><h4 id="数组的传参"><a class="markdownIt-Anchor" href="#数组的传参"></a> 数组的传参</h4><p>数组不能拷贝，所以尽量传数组的引用or指针。但是，传入函数以后，数组变量会退化成 <strong>首元素指针</strong> ，不管形参写的是（1）int* p（2）int p[3] （3）int p[]，函数内部都是把数组变量当成指针看待。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_ptr</span><span class="params">(<span class="keyword">int</span> p[<span class="number">4</span>])</span> </span>&#123;&#125;  <span class="comment">// 传入的本质还是首指针，可以</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_ptr</span><span class="params">(<span class="keyword">int</span> p[])</span> </span>&#123;&#125;  <span class="comment">// 传入的本质还是首指针，可以</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_ptr</span><span class="params">(<span class="keyword">int</span>* p)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_ref</span><span class="params">(<span class="keyword">int</span> (&amp;p)[<span class="number">4</span>])</span> </span>&#123;&#125;  <span class="comment">// 传入以后，数组被转化成 int(&amp;)[4] 类型，不是原来的数组变量 int[4] 类型了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f_ptr</span>(p);  <span class="comment">// 指针，数组 p 被自动识别为指针</span></span><br><span class="line"><span class="built_in">f_ptr</span>(&amp;p[<span class="number">0</span>]);  <span class="comment">// 指针值</span></span><br><span class="line"><span class="built_in">f_ref</span>(p);  <span class="comment">// 引用，相当于传入变量 p</span></span><br></pre></td></tr></table></figure><p><strong>多维数组</strong></p><p>传参：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_ptr</span><span class="params">(<span class="keyword">int</span> (*p)[<span class="number">4</span>])</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>模板法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> rows, <span class="keyword">size_t</span> cols&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_template</span><span class="params">(<span class="keyword">int</span> (&amp;p)[rows][cols])</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"><span class="built_in">f_template</span>(p);  <span class="comment">// 4 和 5 直接变成 rows、cols</span></span><br></pre></td></tr></table></figure><h4 id="总结一些常见用法"><a class="markdownIt-Anchor" href="#总结一些常见用法"></a> 总结一些常见用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1, *p2;</span><br><span class="line"><span class="keyword">int</span> x[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">p1 = &amp;x[<span class="number">0</span>];  <span class="comment">// 指向一个位置</span></span><br><span class="line">p2 = &amp;x[<span class="number">7</span>];</span><br><span class="line">*p1 = *(p2<span class="number">-1</span>);  <span class="comment">// *p1==7，赋值操作，*号取出来的变量</span></span><br></pre></td></tr></table></figure><h3 id="类的指针"><a class="markdownIt-Anchor" href="#类的指针"></a> 类的指针</h3><p>类的指针比较规范（不会出现数组和字符串那种奇奇怪怪的情况）</p><p>在定义一个类的指针，首先需要一个实例化的类：</p><h4 id="用-new-为类分配内存"><a class="markdownIt-Anchor" href="#用-new-为类分配内存"></a> 用 new 为类分配内存</h4><p>new 创建的对象返回指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;* p = <span class="keyword">new</span> vector&lt;<span class="keyword">int</span>&gt;();</span><br></pre></td></tr></table></figure><p>使用箭头运算符访问成员变量：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-tag">-</span>&gt;<span class="selector-tag">size</span>();</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-tag">-</span>&gt;<span class="selector-tag">empty</span>();</span><br><span class="line">(*p)<span class="selector-class">.empty</span>();  <span class="comment">// 等价于解开后的点运算符</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> new 对应的操作是 delete，但是 delete 只是清空指向的内存，指针本身并没有置空 nullptr，</p><h4 id="函数里面-new-的指针"><a class="markdownIt-Anchor" href="#函数里面-new-的指针"></a> 函数里面 new 的指针</h4><p>函数是栈内存，new 是堆内存。如果我们不去手动 delete，那么 new 出来的内存也不会随着函数 return 释放。不过如果能用一个传参进来的指针承接它，并且确保这个指针最后会被释放那就没问题。</p><h4 id="类里面-new-的指针"><a class="markdownIt-Anchor" href="#类里面-new-的指针"></a> 类里面 new 的指针</h4><h4 id="字符串的数组c11已废弃"><a class="markdownIt-Anchor" href="#字符串的数组c11已废弃"></a> 字符串的数组（c++11已废弃）</h4><p>字符串本身就是一个数组，所以字符串的数组应当是：<strong>指针变量的数组</strong></p><p>更新：定义指针的时候不要直接用未分配内存的字符串，这种方法不要用</p><p><strong>注意：</strong> 字符串变量虽然也是数组，但是可以直接交给 cout ，打印出来整个字符串（而不是首元素地址）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *names[] = &#123;</span><br><span class="line">                   <span class="string">&quot;Zara Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Hina Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Nuha Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Sara Ali&quot;</span>,</span><br><span class="line">   			   &#125;;</span><br><span class="line">cout &lt;&lt; names[<span class="number">0</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="引用是什么"><a class="markdownIt-Anchor" href="#引用是什么"></a> 引用是什么</h3><p>一般的赋值，都是值拷贝（修改副本影响不到本体）。下面的例子展示了值拷贝，如果 <strong>a = a + 1</strong> 右边赋给的不是值，而是地址，那会有一个无限迭代（不然 a 永远是 上一个 a 再 + 1）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">a = a + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>引用也可以解决地址拷贝的问题（另一个方法是指针），引用变量就是 a 的替身</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br><span class="line">b = <span class="number">2</span>;  <span class="comment">// a 也跟着变成 2</span></span><br></pre></td></tr></table></figure><h4 id="传参的时候用引用"><a class="markdownIt-Anchor" href="#传参的时候用引用"></a> 传参的时候用引用</h4><p>函数传参进来，默认是值拷贝，从调用的地方把值复制一遍传给函数。函数内部对我们的变量做了任何改动都影响不到外面的本体了</p><p>如果我们需要在函数里面影响到传进来的参数本身（比如修改数组的成员），就要把形参改成引用。</p><p><strong>swap的例子：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改数组元素的例子：</strong></p><p>函数传入一个数组的引用，返回数组某个元素的引用。</p><p><strong>注意：</strong> 函数类型也是引用，引用的定义必须有等号初始化（不能空引用）。传参的时候也必须是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法，即使返回引用，也修改不到原来的nums</span></span><br><span class="line"><span class="comment">// int&amp; setValue(vector&lt;int&gt; nums, int i) &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">setValue</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>&amp; x = nums[i];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">setValue</span>(nums, <span class="number">0</span>) = <span class="number">8</span>;  <span class="comment">// 返回引用就可以修改这个元素啦</span></span><br></pre></td></tr></table></figure><p>方便的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt;&amp; <span class="title">mulValue</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p: nums) p *= i;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，引用就是为了解决传参和出参总是产生副本的问题。（ <strong>从值传递变成引用传递</strong> ）</p><p>当返回一个引用时，要注意被引用的对象不能超出作用域。所以不要返回局部对象的引用，但是，可以返回一个对静态变量的引用。</p><h4 id="原生数组的引用"><a class="markdownIt-Anchor" href="#原生数组的引用"></a> 原生数组的引用</h4><p><strong>引用的数组：</strong> 不存在这个概念</p><p>数组的引用，这样传参：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> (&amp;a)[<span class="number">3</span>])</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>括号优先级最高，形参 a 是引用，对 int[3] 数组变量的引用。如果不加括号，那么参数含义就是 “含有三个 int 引用的数组”，不合法</p><h3 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h3><p><strong>堆内存：</strong> new、malloc 申请出来的，需要手动释放。空间大</p><p><strong>栈内存：</strong> 没用到 new、malloc 的，不用手动释放，空间小。</p><p><strong>malloc：</strong> 分配指定大小字节的内存。返回 void* 空类型的指针。void* 可以强制转换为任何类型的指针，类指针也可以</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* p;</span><br><span class="line">p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line">p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">100</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));  <span class="comment">// 分配 100个整数</span></span><br></pre></td></tr></table></figure><p><strong>new：</strong> 创建一个对象的指针，并为它自动分配内存。注意对象如果没加括号，那么一般不会调用默认的构造函数</p><p><strong>delete：</strong> 释放指针指向的区域，但是指针必须指向初始位置！</p><ul><li>一般的变量，delete 指针 new 内存的地方即可（在 delete 前不可以指向其他地方，不然之前的地方就无人看管了（内存泄露））</li><li>数组变量，在首地址前面的内存记录了数组的长度，delete[] 会根据这个长度释放整个数组。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">++p  <span class="comment">// 不可以移动！不然delete会报错</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 虽然 delete 释放了内存，但指针 p 仍然可以获取先前的地址，并且仍然有数据（delete 并没有删除数据，而只是释放了权限。类似磁盘删除文件，除非在上面覆写，不然仍然可以获取已经删除的数据）。而且还能在这块内存上继续修改，这样是不可控的。所以这就是为什么推荐 delete 完以后置空指针，初始化地址。</p><h4 id="拷贝内存"><a class="markdownIt-Anchor" href="#拷贝内存"></a> 拷贝内存</h4><p><strong>memcpy：</strong> 从 src 地址开始，拷贝一定长度的内存数据到 dst 地址上面。存在地址重叠的问题，如果 dst 和 src 间隔太近，逐个拷贝 src 的数据过去会导致 src 看管的区间被污染，导致拷贝失败。</p><p><strong>memmove：</strong> 在拷贝前检测 dst 和 src 的地址，如果会重叠就从尾部开始拷贝。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">int</span>* src = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* dst = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(dst, src, <span class="number">5</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(src));</span><br><span class="line"><span class="built_in">memmove</span>(dst, src, <span class="number">5</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(src));</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> memmove 只是拷贝，不是真正意义的 ‘move’ ，所以 src 如果是 new 出来的还是得 delete 释放。</p><h4 id="指针和-const"><a class="markdownIt-Anchor" href="#指针和-const"></a> 指针和 const</h4><p><strong>指向常量的指针：</strong> 不能改变指向对象的值（不代表对象不能改变！只是这个指针没有权限修改）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p1 = &amp;x;</span><br><span class="line"><span class="keyword">int</span>* p2;</span><br><span class="line">*p1 = <span class="number">300</span>;  <span class="comment">// 不可以！</span></span><br><span class="line">p2 = p1;  <span class="comment">// 不可以！p1 指向的是常量，p2 指向的是变量</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 不可以用指向常量的指针给正常指针赋值！不然赋值以后的正常指针就要对常量的内存修改了。</p><p><strong>指针指向常量：</strong> 为了避免指针修改常量，只有指针发誓自己是只读的（指向常量的指针），编译器才允许指针获取到常量的地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">0</span>;  <span class="comment">// 一个常量</span></span><br><span class="line"><span class="keyword">int</span>* p = &amp;a;  <span class="comment">// 错误，普通的指针无法获取到 a 的地址，为了避免修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p = &amp;a;  <span class="comment">// 正确，一个指向常量的指针被允许</span></span><br></pre></td></tr></table></figure><p><strong>指向常量的引用：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x1 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; x2 = x1;  <span class="comment">// 可以</span></span><br><span class="line"><span class="keyword">int</span>&amp; x2 = x1;  <span class="comment">// 不可以！</span></span><br></pre></td></tr></table></figure><p><strong>const 指针：</strong> 指针本身也是对象，也可以是一个常量变量（注意区别 <strong>指向常量的指针</strong> ）。叫做 <strong>常量指针</strong> 。</p><p>常量指针在创建的时候必须初始化，而且初始化完成以后，它指向的地方就不可以改变了（不过它指向的值可以变）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x[<span class="number">2</span>] &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = x;</span><br><span class="line">p = x + <span class="number">1</span>;  <span class="comment">// 不可以！</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 看 const 的位置，从右往左，const int* p 表示 p 指向的对象不可变，int* const p 表示变量 p 本身不可变</p><p>也可以有双重 const 的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = <span class="string">&quot;12345&quot;</span></span><br></pre></td></tr></table></figure><p><strong>野指针：</strong> 没有初始化的指针，指向一个随机的地方。编译器会警告这个行为。</p><p><strong>悬垂指针：</strong> free 或者 delete 以后虽然内存清空了，但是指针变量还拥有那块内存地址的权限，他们有可能对内存做出无法预测的操作。（避免这个的办法是重新赋值为 nullptr 置空）</p><p><strong>内存泄露：</strong> 和野指针相反，指针看管的 new 或者 malloc 出来的内存还在使用中，指针却提取被置空 nullptr 了，此时这块内存就无人看管了，长此以往可以用的内存越来越少。换个角度，只要 new 出来的内存有可控制的指针在看管，那么旧的指针指向其他地方或者随着作用域变化销毁了，都是没关系的。</p><h3 id="shared_ptr"><a class="markdownIt-Anchor" href="#shared_ptr"></a> shared_ptr</h3><p>共享指针：带有引用计数功能并且支持拷贝的指针，没有人需要这个指针指向的地方，共享指针就会自动释放内存。而且共享指针可以有多个看管同一块内存，即使一个指针离开了作用域，也可以确保其他指针的正常使用（内存只有全部指针都离开才会释放）</p><p>共享指针具有两种功能（1）引用（2）解引用。（1）包括接管初始化的新动态内存，获取其他共享指针的权限（2）包括指向另外的共享指针，或者重设成其他的裸指针</p><h4 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h4><p>有以下方法初始化共享指针，不初始化的话就是空指针，node1 和 node5 是等价的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;ListNode&gt; node1;  <span class="comment">// 默认构造函数 ListNode</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;ListNode&gt; <span class="title">node2</span><span class="params">(node1)</span></span>;  <span class="comment">// 拷贝构造，共享对象，引用计数+1</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;ListNode&gt; <span class="title">node3</span><span class="params">(<span class="keyword">new</span> ListNode(<span class="number">3</span>))</span></span>;  <span class="comment">// 3</span></span><br><span class="line">std::shared_ptr&lt;ListNode&gt; node4 = std::make_shared&lt;ListNode&gt;(<span class="number">3</span>);  <span class="comment">// 用 make_shared 完成对象的初始化</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;ListNode&gt; <span class="title">node5</span><span class="params">(<span class="literal">nullptr</span>)</span>  <span class="comment">// 空指针，引用计数为0。等号赋值初始化也可以。</span></span></span><br><span class="line"><span class="function">std::shared_ptr&lt;ListNode&gt; <span class="title">node6</span><span class="params">(<span class="keyword">new</span> ListNode(<span class="number">4</span>), [](ListNode* p) &#123; <span class="keyword">delete</span>[] p; &#125;)</span>  <span class="comment">// 提供删除操作</span></span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> new 出来的内置指针不可以隐式转换成共享指针（等号赋值、传参）。只能在直接初始化的时候转换，见上面的例子 3。也不要用同一块 new 出来的指针初始化多个 shared_ptr，会直接导致多次释放错误。</p><p><strong>注意：</strong> make_shared 针对有构造函数的对象，如果是 int 数组这种，还是用括号 new 的构造方式</p><h4 id="reset-和赋值的区别"><a class="markdownIt-Anchor" href="#reset-和赋值的区别"></a> reset 和赋值的区别</h4><p><strong>reset：</strong> 接受新开辟的裸指针</p><p><strong>赋值：</strong> 等号右边是共享指针</p><p>下面两种方法是一样的效果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">p = std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h4 id="管理-new-出来的数组动态数组"><a class="markdownIt-Anchor" href="#管理-new-出来的数组动态数组"></a> 管理 new 出来的数组（动态数组）</h4><p>shared_ptr 不支持方括号取下标，还不支持管理动态数组，除非提供自定义删除器。而且不能 make_shared 初始化动态数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>], [] (<span class="keyword">int</span>* p) &#123; <span class="keyword">delete</span>[] p; &#125;);</span><br><span class="line">p.<span class="built_in">reset</span>();  <span class="comment">// 起到 delete 动态数组的效果</span></span><br><span class="line">p.<span class="built_in">get</span>()[<span class="number">0</span>];  <span class="comment">// 用get 来访问下标</span></span><br></pre></td></tr></table></figure><p>传参的时候传引用，把共享指针看成是一个指针类使用即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> shared_ptr&lt;<span class="keyword">int</span>&gt;&amp; p)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>**get： ** 获取只读版本指针地址。切记 get( ) 得到的指针地址不可修改也不可用于赋值，共享指针的赋值得用类赋值而不是底层裸指针。</p><p><strong>use_count：</strong> 查看该共享指针地址被其他共享指针引用的次数，默认 1 次，两个一起共享就 2 次。</p><p><strong>reset：</strong> 接受普通指针，绑定到新的对象。导致原来的引用计数 -1</p><p>支持指针本身有的 * 和 -&gt; 运算符</p><h4 id="错误的初始化"><a class="markdownIt-Anchor" href="#错误的初始化"></a> 错误的初始化</h4><p>如果用其他共享指针的地址初始化，引用计数不会 + 1， p1 和 p2 都是 1 的引用计数而且看管同一块地址。会导致重复销毁一块地址两次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p1 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(p1.get())</span></span>;  <span class="comment">// 错误</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><h4 id="错误的传参"><a class="markdownIt-Anchor" href="#错误的传参"></a> 错误的传参</h4><p>不要在传参的时候，创建临时的共享指针，他们会在表达式结束被销毁</p><p><strong>临时对象的生命周期：</strong> 到分号为止，到下条语句的时候，临时对象就已经销毁了。</p><h4 id="类里面的共享指针"><a class="markdownIt-Anchor" href="#类里面的共享指针"></a> 类里面的共享指针</h4><p>再次强调不要用裸指针为多个共享指针初始化（会导致引用计数分别计算，释放重复），而是只初始第一个共享指针，然后用它·为剩下的共享指针初始化</p><h4 id="const-的共享指针"><a class="markdownIt-Anchor" href="#const-的共享指针"></a> const 的共享指针</h4><p>和裸指针不一样，const shared_ptr 指的是该智能指针只读，也就是不会重新赋值，所以对应的是 T* const p （常量指针指向 T）。模板里面 const T 表明指向的是 常量 T。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shared_ptr&lt;T&gt; p;       ---&gt; T * <span class="keyword">const</span> p;</span><br><span class="line">shared_ptr&lt;<span class="keyword">const</span> T&gt; p;       ---&gt; <span class="keyword">const</span> T * p; </span><br><span class="line"><span class="keyword">const</span> shared_ptr&lt;<span class="keyword">const</span> T&gt; p; ---&gt; <span class="keyword">const</span> T * <span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure><h4 id="一个链表的例子"><a class="markdownIt-Anchor" href="#一个链表的例子"></a> 一个链表的例子</h4><p>用共享指针建立的链表需要头结点维持，因为头结点引用二号结点，二号结点引用三号，后面的结点依赖前面的引用维持，每个的引用计数都是 1。如果链表中某个结点重新赋值导致引用计数清空，那么它原本指向的后面的一串链表都会随着释放。</p><p>下面把头结点的 next 置空了，导致头结点后面的链表全部因为连锁反应被释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    std::shared_ptr&lt;ListNode&gt; next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> v, std::shared_ptr&lt;ListNode&gt; n): <span class="built_in">val</span>(v), <span class="built_in">next</span>(n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;ListNode&gt; <span class="title">node</span><span class="params">(<span class="keyword">new</span> ListNode(<span class="number">3</span>, <span class="literal">nullptr</span>))</span></span>;</span><br><span class="line">node-&gt;next = std::make_shared&lt;ListNode&gt;(<span class="number">4</span>, <span class="literal">nullptr</span>);  <span class="comment">// 在后面添加结点</span></span><br><span class="line">node.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>, node));  <span class="comment">// 在前面添加结点</span></span><br><span class="line">node = std::make_shared&lt;ListNode&gt;(<span class="number">5</span>, node);  <span class="comment">// 在前面添加结点</span></span><br><span class="line">node-&gt;next = <span class="literal">nullptr</span>;  <span class="comment">// 引用计数 -1</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> next 包含解引用，属于是原位修改，而结点本身的指针只是一个观察器</p><h3 id="unique_ptr"><a class="markdownIt-Anchor" href="#unique_ptr"></a> unique_ptr</h3><p>独占指针：地址只能由自己看管，所以必须用 new 出来的内存初始化，而不是其他指针初始化。unique_ptr 的拷贝构造函数被 delete 了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;  <span class="comment">// c++11 没有 make_unique</span></span><br></pre></td></tr></table></figure><p>release：解除独占权，返回指针地址，智能指针被置空。</p><p>reset：销毁之前的内存，重新接管新的地址。没有参数就是销毁指针。</p><p>release 和 reset 配合使用，交接权限。release 类似移动语义，传递完地址后就置空了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p1.<span class="built_in">reset</span>(p2.<span class="built_in">release</span>());  <span class="comment">// p2 解除权限，继承给 p1</span></span><br><span class="line">p1.<span class="built_in">reset</span>();  <span class="comment">// 释放内存，置空指针</span></span><br><span class="line"><span class="comment">// p2: nullptr</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p3</span><span class="params">(p1.release())</span>  <span class="comment">// 还可以把 p1 转让给共享指针</span></span></span><br></pre></td></tr></table></figure><p>共享指针可以接收右值独占指针，继承内存权限。</p><h3 id="函数指针"><a class="markdownIt-Anchor" href="#函数指针"></a> 函数指针</h3><p>前面提到的技巧：星号翻译成指向。函数指针的声明是星号和变量用括号括起来，剩下的部分和指向的函数一致</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*pf)(<span class="keyword">int</span>) = f;</span><br></pre></td></tr></table></figure><h4 id="调用"><a class="markdownIt-Anchor" href="#调用"></a> 调用</h4><p>无论解不解引用都可以调用函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*pf)(<span class="keyword">int</span>);</span><br><span class="line"><span class="built_in">pf</span>(<span class="number">1</span>);  <span class="comment">// ok</span></span><br><span class="line">(*pf)(<span class="number">1</span>);  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/posts/1527658047/" rel="prev" title="Rmarkdown里面的表格"><i class="fa fa-chevron-left"></i> Rmarkdown里面的表格</a></div><div class="post-nav-item"><a href="/posts/415903961/" rel="next" title="C++的vector">C++的vector <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备2022005339号 </a><img src="/images/beian.png" alt=""><a href="http://beian.gov.cn/portal/registerSystemInfo?recordcode=11010802038986" rel="noopener" target="_blank">京公网安备 11010802038986号</a></div><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="author" itemprop="copyrightHolder">陈涵</span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" integrity="sha256-9/mhQQwkpU5okPfM5l0v3LnP9xtc6JK8dKW0/WlGaUc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/copy-tex.min.css" integrity="sha256-+oItviPaTmqjDhk4y4fLLUIMgRQYDV/ZyrRNvQiebWM=" crossorigin="anonymous"><script class="next-config" data-name="katex" type="application/json">{"copy_tex_js":{"url":"https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/copy-tex.min.js","integrity":"sha256-etSqbSVF4+Lwe8MGk/Vanc1sR+mWv+qOG73fxWw9p94="}}</script><script src="/js/third-party/math/katex.js"></script><script class="next-config" data-name="valine" type="application/json">{"enable":true,"appId":"UoQeuqgdeldMdxmboc6kUTKW-gzGzoHsz","appKey":"m1YPDJalPP8O4keGQyTXXAM5","serverURLs":"https://uoqeuqgd.lc-cn-n1-shared.com","placeholder":"欢迎评论","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":false,"enableQQ":false,"requiredFields":[],"notify":"45_cph@163.com","el":"#valine-comments","path":"/posts/3219915228/","libUrl":"https://lib.baomitu.com/valine/latest/Valine.min.js"}</script><script>document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.valine.el)
    .then(() => NexT.utils.getScript(
      CONFIG.valine.libUrl,
      { condition: window.Valine }
    ))
    .then(() => {
      new Valine(CONFIG.valine);
    });
});</script></body></html>